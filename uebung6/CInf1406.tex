\documentclass{CInf_practice}

\sheet{6}{Flipflops und Registerschaltungen}

\begin{document}
\cinftitle

\ex{Zweiflankensteuerung}{5 + 7 }
\begin{center}
  \noindent\begin{tikzpicture}[xscale=.7, yscale=.8]

    % helpers
    \def\hAzero{1.4}  \def\hAone{1.8}
    \def\hBzero{0.4}  \def\hBone{0.8}
    \def\hCyzero{3.4} \def\hCyone{3.8}
    \def\hDzero{2.4}  \def\hDone{2.8}

    \def\diff{.4}

    % undefs
    \def\drawundef#1#2{\fill[gray!40] (0, #1) rectangle ++(#2, -\diff);}

    % grid
    \foreach \x in {1,...,16}{
      \draw[dotted] (\x, 0) -- ++(0,4);
    }

    % draw helpers
    \def\drawAt#1#2{\draw (#1,#2) -- ++(1,0);}
    \def\connect#1#2{\draw (#2,#1) -- ++(0,\diff);}

    % draw cycle
    \foreach \x in {0,2,...,16}{
      \drawAt{\x}{\hCyzero}
      \connect{\hCyzero}{\x}
    }
    \foreach \x in {1,3,...,16}{
      \drawAt{\x}{\hCyone}
      \connect{\hCyzero}{\x}
    }

    % draw D
    \def\up{, \hDzero) -- ++(0, \diff) -- (}
    \def\dn{, \hDone)  -- ++(0, -\diff) -- (}
    \draw (0, \hDone) -- (.7 \dn 2.1 \up 2.5 \dn 2.7 \up 3.5 \dn 5.1 \up 5.4 \dn 
                         6.8 \up 7.3 \dn 7.4 \up 7.6 \dn 7.9 \up 9.3 \dn 10.2 \up
                         12.3 \dn 12.5 \up 13.5 \dn 16.1 \up 17, \hDone);

    % draw A
    \def\up{, \hAzero) |- ++(0, \diff) -- (}
    \def\dn{, \hAone)  -- ++(0, -\diff) -- (}
    \drawundef{\hAone}{2}
    \draw (2, \hAzero) -- (4 \up 6 \dn 8 \up 16 \dn 17, \hAzero);

    % draw B
    \def\up{, \hBzero) -- ++(0, \diff) -- (}
    \def\dn{, \hBone)  -- ++(0, -\diff) -- (}
    \drawundef{\hBone}{1}
    \draw (1, \hBone) -- (3 \dn 9 \up 11 \dn 13 \up 15 \dn 17, \hBzero);

    % axes
    \foreach \name/\y in {C/4,D/3,a)/2,b)/1}{
      \draw[<-] (0,\y) -- ++(0,-.7) node[anchor=south east] {\name};
    }
    \foreach \y in {.3,1.3,2.3,3.3}{
      \draw[->] (0,\y) -- ++(17,0) node[anchor=north west] {t};
    }
  \end{tikzpicture}
\end{center}

\ex{JK-Flipflops}{6 + 6 + 6 }
\begin{center}
  \noindent\begin{tikzpicture}[xscale=.8,yscale=.7]

    % helpers
    \def\hAzero{2.4}  \def\hAone{2.8}
    \def\hBzero{1.4}  \def\hBone{1.8}
    \def\hCzero{0.4}  \def\hCone{0.8}
    \def\hCyzero{5.4} \def\hCyone{5.8}
    \def\hJzero{4.4}  \def\hJone{4.8}
    \def\hKzero{3.4}  \def\hKone{3.8}

    \def\diff{.4}

    % undefs
    \def\drawundef#1#2{\fill[gray!40] (0, #1) rectangle ++(#2, -\diff);}
    

    % grid
    \foreach \x in {1,...,16}{
      \draw[dotted] (\x, 0) -- ++(0,6);
    }

    % draw cycle
    \def\drawAt#1#2{\draw (#1,#2) -- ++(1,0);}
    \def\connect#1#2{\draw (#2,#1) -- ++(0,\diff);}
    \foreach \x in {0,2,...,16}{
      \drawAt{\x}{\hCyzero}
      \connect{\hCyzero}{\x}
    }
    \foreach \x in {1,3,...,16}{
      \drawAt{\x}{\hCyone}
      \connect{\hCyzero}{\x}
    }

    % draw J
    \def\up{, \hJzero) -- ++(0, \diff) -- (}
    \def\dn{, \hJone)  -- ++(0, -\diff) -- (}
    \draw (0, \hJzero) -- (.7 \up 1.6 \dn 2.3 \up 2.6 \dn 3.5 \up 4.2 \dn 
                          5.4 \up 7.5 \dn 10.3 \up 10.45 \dn 11.6 \up 
                          17, \hJone);
    
    % draw K
    \def\up{, \hKzero) -- ++(0, \diff) -- (}
    \def\dn{, \hKone)  -- ++(0, -\diff) -- (}
    \draw (0, \hKzero) -- (4.7 \up 4.9 \dn 5.5 \up 6.6 \dn 8.3 \up 8.4 \dn 
                           8.7 \up 9.5 \dn 10.5 \up 10.65 \dn 12.5 \up 
                           17, \hKone);

    % draw A
    \def\up{, \hAzero) |- ++(0, \diff) -- (}
    \def\dn{, \hAone)  -- ++(0, -\diff) -- (}
    \drawundef{\hAone}{1}
    \draw (1, \hAone) -- (5 \dn 7 \up 9 \dn 11 \up 13 \dn 15 \up 17, \hAone);
    

    % draw B
    \def\up{, \hBzero) -- ++(0, \diff) -- (}
    \def\dn{, \hBone)  -- ++(0, -\diff) -- (}
    \drawundef{\hBone}{2}
    \draw (2, \hBone) -- (10 \dn 14 \up 16 \dn 17, \hBzero);
    
    % draw C
    \def\up{, \hCzero) |- ++(0, \diff) -- (}
    \def\dn{, \hCone)  -- ++(0, -\diff) -- (}
    \drawundef{\hCone}{5}
    \draw (5, \hCone) -- (7 \dn 13 \up 15 \dn 17, \hCzero);
    
    % axes
    \foreach \name/\y in {C/6,J/5,K/4,a)/3,b)/2,c)/1}{
      \draw[<-] (0,\y) -- ++(0,-.7) node[anchor=south east] {\name};
    }
    \foreach \y in {.3,1.3,2.3,3.3,4.3,5.3}{
      \draw[->] (0,\y) -- ++(17,0) node[anchor=north west] {t};
    }
    
  \end{tikzpicture}
\end{center}

\newpage
\ex{Multifunktions-Schieberegister}{10 + 5 +2 }

\subex{}
\tikzstyle{muxer}=[minimum size=1cm,shape=trapezium,draw,shape border rotate=270]
\tikzstyle{flipflop}=[minimum height=1.5cm,minimum width=1cm,draw]
\usetikzlibrary{shapes}
\newcommand{\flipflop}[2]{
   \node[flipflop,#2] (#1) {};
   \node[right,font=\tiny] (#1-D) at ($(#1.north west) + (0,-10pt)$) {1D};
   \node[left,font=\tiny] (#1-out) at ($(#1.north east) + (0,-10pt)$) {Q};
   \node[isosceles triangle,anchor=west,draw,inner sep=0,minimum width=4pt]
   (#1-clk) at (#1.190) {};
   \node[font=\tiny] (C1) at ($(#1.190) + (1em,0)$) {C1};
   \draw[dashed] (C1) ++(5pt,0) -- (#1.350);
   \path[name path=#1-clk-path] (#1-clk) -- ++(-1em,0) -- ++(0,-5cm);
}
\newcommand{\muxer}[2]{
   \node[muxer,#2] (#1) {};
   \draw 
   let \p1 = ($(#1.bottom left corner) - (#1.bottom right corner)$),
   \n1 = {0.2*veclen(\x1,\y1)}
   in (#1.bottom left corner) +(0,-\n1)   node[anchor=west] (#1-0) {} node[right,font=\tiny] {10}
   (#1.bottom left corner) +(0,-2*\n1) node[anchor=west] (#1-1) {} node[right,font=\tiny] {00}
   (#1.bottom left corner) +(0,-3*\n1) node[anchor=west] (#1-2) {} node[right,font=\tiny] {01}
   (#1.bottom left corner) +(0,-4*\n1) node[anchor=west] (#1-3) {} node[right,font=\tiny] {11};
   \node[anchor=south] (#1-s0) at (#1.-80) {};
   \node[anchor=south] (#1-s1) at (#1.-100) {};
   \path[name path=#1-s0-path] (#1-s0) -- ++(0,-5cm);
   \path[name path=#1-s1-path] (#1-s1) -- ++(0,-5cm);

   \node[font=\tiny,left=3pt of #1-3] (tmp) {0};
   \draw (tmp) ++(3pt,0) -- (#1-3);

   \node[anchor=east] (#1-out) at (#1.top side) {};
}
\newcommand{\drawcommands}[1]{
   \draw[name intersections={of={#1-s0-path and s0}}] (#1-s0) --
   (intersection-1) coordinate (c);
   \fill (c) circle(1pt);
   \draw[name intersections={of={#1-s1-path and s1}}] (#1-s1) --
   (intersection-1) coordinate (c);
   \fill (c) circle (1pt);

}
\newcommand{\drawclock}[1]{
   \draw[name intersections={of={#1-clk-path and clk}}] (#1-clk) -|
   (intersection-1);
   \fill[name intersections={of={#1-clk-path and clk}}] (intersection-1) circle (1pt);
}
\newcommand{\connectbackwards}[3]{
   \draw (#1-out) -- ++(1em,0) coordinate (c1);
   \draw (c1) -- ++(0,#3+1cm) |- ($(#2-0) + (-1em,#3+1cm)$) |- (#2-0);
   \fill (c1) circle (1pt);
}
\noindent\begin{tikzpicture}[node distance=.5cm]
   \path[name path=s0] (0,2em) -- (\linewidth,2em);
   \draw (0,2em) node (s2) {$s_0$} ++(1em,0) -- ++(7cm,0) coordinate (c);
   \draw[dotted] (c) -- ++(1cm,0) coordinate (c2);
   \draw (c2) -- ++(6cm,0);

   \path[name path=s1] (0,1em) -- (\linewidth,1em);
   \draw (0,1em) node (s1) {$s_1$} ++(1em,0) -- ++(7cm,0)
   coordinate (c);
   \draw[dotted] (c) -- ++(1cm,0) coordinate (c2);
   \draw (c2) -- ++(6cm,0);

   \path[name path=clk] (0,0) -- (\linewidth,0);
   \draw (0,0) node (clk) {CLK} ++(1em,0) -- ++(7cm,0)
   coordinate (c);
   \draw[dotted] (c) -- ++(1cm,0) coordinate (c2);
   \draw (c2) -- ++(6cm,0);

   % ASSEMBLY 1 %%%%%%%%%%%%%
   \muxer{mux-7}{above right=1cm and 1cm of s2}
   \flipflop{fl-7}{right=of mux-7}
   \drawcommands{mux-7}
   \drawclock{fl-7}
   %%%%%%%%%%%%%%%%%%%%%%%%%%

   % ASSEMBLY 2 %%%%%%%%%%%%%
   \muxer{mux-6}{right=1cm of fl-7}
   \flipflop{fl-6}{right=of mux-6}
   \drawcommands{mux-6}
   \drawclock{fl-6}
   %%%%%%%%%%%%%%%%%%%%%%%%%%

   \connectbackwards{fl-6}{mux-7}{-10pt}

   \draw (fl-7-out) -- ++(1em,0) coordinate (c3) |- (mux-6-2);
   \fill (c3) circle (1pt);

   \draw (mux-7-out) -- ++(1em,0) |- (fl-7-D);

   \draw (mux-6-out) -- ++(1em,0) |- (fl-6-D);

   \draw[dotted] (fl-6-out) -- ++(1cm,0);

   % ASSEMBLY 3 %%%%%%%%%%%%%
   \muxer{mux-1}{right=2cm of fl-6};
   \flipflop{fl-1}{right=of mux-1};
   \drawcommands{mux-1}
   \drawclock{fl-1}
   %%%%%%%%%%%%%%%%%%%%%%%%%%

   \draw (mux-1-out) -- ++(1em,0) |- (fl-1-D);

   % ASSEMBLY 4 %%%%%%%%%%%%%
   \muxer{mux-0}{right=1cm of fl-1};
   \flipflop{fl-0}{right=of mux-0};
   \drawcommands{mux-0}
   \drawclock{fl-0}
   %%%%%%%%%%%%%%%%%%%%%%%%%%

   \draw (mux-0-out) -- ++(1em,0) |- (fl-0-D);

   \draw (fl-1-out) -- ++(1em,0) coordinate (c) |- (mux-0-2);
   \fill (c) circle (1pt);
   \draw (c) -- ++(0,2em) -- ++(-2.5cm,0) coordinate (c);
   \draw[dotted] (c) -- ++(-1cm,0);

   \connectbackwards{fl-0}{mux-1}{-10pt}

   \draw (fl-0-out) -- ++(1cm,0);

   \draw (fl-0-out) -- ++(2em,0) coordinate (c1);
   \draw (c1) -- ++(0,1cm) |- ($(mux-7-0) + (-2em,1cm)$) |- (mux-7-2);
   \fill (c1) circle (1pt);

   \draw (c3) -- ++(0,2cm) -| ($(mux-0-0) + (-2em,1cm)$) |- (mux-0-0);

   \foreach \x in {7,6,1,0}{
      \node[above=3cm of fl-\x] (tmp) {D$_\x$};
      \draw[->] (tmp) -- ++(0,-1cm);
      % actual data inputs D_i
      \node[font=\tiny,left=3pt of mux-\x-1] (tmp) {D$_\x$};
      \draw (tmp) ++(5pt,0) -- (mux-\x-1);
   }

   \draw (mux-6-0) -- ++(-1em,0) -- ++(0,0.8cm) -- ++(3cm,0) coordinate (c);
   \draw[dotted] (c) -- ++(1cm,0);

   \draw (mux-1-2) -- ++(-1em,0) coordinate (c);
   \draw[dotted] (c) -- ++(-1em,0);
\end{tikzpicture}

Die Eingänge D$_i$ müssen geeignet beschaltet werden, um die Flipflops zu laden.
Der Übersichtlichkeit halber sind hier keine weiteren Leitungen eingezeichnet.

\subex{}

Für aktuellen Zustand $Q^n$ und gewünschten Folgezustand $Q^{n+1}$ sind folgende
D- bzw. T-Signale nötig.
\begin{center}
   \begin{tabular}{>{$}l<{$}|>{$}l<{$}|>{$}c<{$}|>{$}c<{$}}
      Q^n & Q^{n+1} & T & D \\\hline\hline
      0 & 0 & 0 & 0\\
      0 & 1 & 1 & 1\\
      1 & 0 & 1 & 0\\
      1 & 1 & 0 & 1
   \end{tabular}
\end{center}

Somit gilt für $T$: 
\begin{equation*}
   T = \comp D Q + D \comp Q = D \oplus Q
\end{equation*}

Das für ein T-Flipflop erforderliche T-Signal kann also wie folgt generiert
werden:

\begin{center}
   \begin{tikzpicture}
      \node[or port,font={=1}] (xor-1) {};
      \node[flipflop,right=of xor-1] (fl-1) {};
      \node[right,font=\tiny] (fl-1-T) at ($(fl-1.north west) + (0,-10pt)$) {T};
      \node[left,font=\tiny] (fl-1-out) at ($(fl-1.north east) + (0,-10pt)$) {Q};
      \node[left,font=\tiny] (fl-1-out-neg) at ($(fl-1.south east) + (0,10pt)$)
      {$\bar{\text{Q}}$};
      \node[isosceles triangle,anchor=west,draw,inner sep=0,minimum width=4pt]
      (fl-1-clk) at ($(fl-1.south west) + (0,10pt)$)  {};

      \node[left=of xor-1.200] (D) {D};
      \draw (D.east) -- (xor-1.200);
      \draw (fl-1-out) -- ++(1em,0) coordinate (c) -- ++(1em,0);
      \draw (fl-1-out-neg) -- ++(1em,0) -- ++(1em,0);
      \fill (c) circle (1pt);
      \draw (c) |- ($(xor-1.160) + (-1em,1cm)$) |- (xor-1.160);
      \draw (xor-1.east) -- ++(1em,0) |- (fl-1-T);
   \end{tikzpicture}
\end{center}

Man ersetzt also alle D-Flipflops durch obige Konstruktion und muss an den
Multiplexern nichts ändern.

\newpage
\subex{}

Zur Erhöhung der Breite genügt es, die gewünschte Anzahl von
Muxer-Flipflop-Bausteinen hintereinanderzuschalten. Wichtig ist bloß, dass der
erste mit dem letzten und umgekehrt verbunden ist, so wie oben zu sehen.




\ex{NRZI-Codierer}{3 + 2 + 4 + 2 + 4 + 4 }
\subex{}

\begin{center}
   \noindent\begin{tikzpicture}
      \def\pulsewidth{.4} % half clock cycle width
      \def\plotlength{13} % total horizontal size

      % helpers
      \def\hCzero{2.4} \def\hCone{2.8}
      \def\hDzero{1.4} \def\hDone{1.8}
      \def\hNzero{0.4} \def\hNone{0.8}

      \def\diff{.4} % difference between 0 and 1

      % grid
      \foreach \name/\y in {C/3,Data/2,NRZI/1}{
         \draw[<-] (0,\y) -- ++(0,-.7) node[anchor=south east] {\name};
      }
      \foreach \y in {0.3,1.3,2.3}{
         \draw[->] (0,\y) -- ++(\plotlength,0) node[anchor=north west] {t};
      }
      \foreach \x in {1,...,32}{
         \draw[dotted] (\x*\pulsewidth,0) -- ++(0,3);
      }

      \foreach \x in {0,2,...,31}{
         \draw (\x*\pulsewidth,\hCzero) -| ++(\pulsewidth,\diff) -|
         ++(\pulsewidth,-\diff);
      }

      % 'boolean' to switch between drawing 0-lines and 1-lines. Can I use
      % something other than counters for this?
      \newcounter{up} 
      \newcommand{\drawcycle}[2]{
         \setcounter{up}{0}

         \begin{scope} % make scope so only stuff in this cycle is clipped
            \clip #1 rectangle ++(12.9,\diff);

            %%% Draw the cycle
            % we always save the point where the last line segment ended, initially at
            % the origin
            \coordinate (c-0) at #1;
            % give the list with each x, where the unit of x \pulsewidth, at which a
            % signal change occurs.
            \foreach \wendepunkt[count=\c, % index in the list
               remember=\c as \last (initially 0), % previous index
            ] in
            {#2}{
               \ifthenelse{\value{up}=0}{ % if 0-line
                  \draw (c-\last) -| ($#1 + (\pulsewidth*\wendepunkt,\diff)$) coordinate (c-\c);
                  \setcounter{up}{1} % this is a signal change, so next will be 1-line
               }{
                  \draw (c-\last) -| ($#1 + (\pulsewidth*\wendepunkt,0)$) coordinate (c-\c);
                  \setcounter{up}{0} % next will be 0-line
               }
            }
         \end{scope}
      }
      \drawcycle{(0,\hDzero)}{2.5,4.6,5.6,7.1,10.2,10.7,11.8,15.5,16.5,18.7,21.2,24.2,25.9,30.7,32.3}
      \drawcycle{(0,\hNzero)}{3,7,13,15,17,23,27,29,40}
   \end{tikzpicture}
\end{center}

\subex{}

\begin{center}
   \begin{tikzpicture}
      \node[minimum width=5cm,minimum height=2cm,draw] (kasten) {NRZI};
      \node[isosceles triangle,inner sep=0,minimum height=10pt,draw,anchor=west] at
      (kasten.190)(clk-port){};
      \node[font=\tiny,right=2pt of clk-port] {CLK};
      \node[above=of kasten] (D) {Data};
      \node[below=of kasten] (N) {N};
      \draw[->] (D.south) -- (kasten);
      \draw[<-] (N.north) -- (kasten);
      \draw (clk-port.west) -| ++(-2em,-1cm);
   \end{tikzpicture}
\end{center}

\newpage
\subex{}

Der Zustandsgraph ist
\usetikzlibrary{automata}
\begin{center}
   \begin{tikzpicture}[node distance=2cm]
      \node[state] (1) {1/1};
      \node[state,right=of 1,initial] (0) {0/0};
      \path[->]
      (1) edge[bend left] node[above] {1} (0)
      (0) edge[bend left] node[below] {1} (1)
      (0) edge[loop right] node[right] {0} ()
      (1) edge[loop left] node[left] {0} ();
   \end{tikzpicture}
\end{center}
\subex{}

Die Übergangstabelle für aktuellen Zustand $Q^n$ und gewünschten Folgezustand
$Q^{n+1}$ ist
\begin{center}
   \begin{tabular}{>{$}c<{$}>{$}c<{$}|>{$}c<{$}}
      Q^n & \text{Data} & Q^{n+1} \\\hline
      0 & 1 & 1 \\
      1 & 0 & 1 \\
      1 & 1 & 0 \\
      0 & 0 & 0
   \end{tabular}
\end{center}

Ein positive einflankengesteuertes T-Flipflop ist bereits ein NRZI-Codierer, da
es immer dann togglet, wenn am Eingang eine 1 anliegt.

\begin{center}
   \begin{tikzpicture}
      \node[flipflop] (fl-1) {};
      \node[right,font=\tiny] (fl-1-T) at ($(fl-1.north west) + (0,-10pt)$) {T};
      \node[left,font=\tiny] (fl-1-out) at ($(fl-1.north east) + (0,-10pt)$) {Q};
      \node[left,font=\tiny] (fl-1-out-neg) at ($(fl-1.south east) + (0,10pt)$)
      {$\bar{\text{Q}}$};
      \node[isosceles triangle,anchor=west,draw,inner sep=0,minimum width=4pt]
      (fl-1-clk) at ($(fl-1.south west) + (0,10pt)$)  {};

      \node[left=of fl-1-T] (D) {D};
      \draw (D.east) -- (fl-1-T);
      \draw (fl-1-out) -- ++(2em,0);
      \draw (fl-1-out-neg) -- ++(2em,0);
      \draw (fl-1-clk) -| ++ (-1em,-1cm);
   \end{tikzpicture}

\end{center}

\subex{}

Ähnlich wie oben kann man aus einem T-Flipflop ein D-Flipflop machen, indem man
ein XOR-Gatter vorschaltet. Man sieht, dass das Flipflop den Zustand wechselt,
wenn am Dateneingang 1 anliegt.

\begin{center}
   \begin{tikzpicture}
      \node[or port,font={=1}] (xor-1) {};
      \node[flipflop,right=of xor-1] (fl-1) {};
      \node[right,font=\tiny] (fl-1-T) at ($(fl-1.north west) + (0,-10pt)$) {D};
      \node[left,font=\tiny] (fl-1-out) at ($(fl-1.north east) + (0,-10pt)$) {Q};
      \node[left,font=\tiny] (fl-1-out-neg) at ($(fl-1.south east) + (0,10pt)$)
      {$\bar{\text{Q}}$};
      \node[isosceles triangle,anchor=west,draw,inner sep=0,minimum width=4pt]
      (fl-1-clk) at ($(fl-1.south west) + (0,10pt)$)  {};

      \node[left=of xor-1.200] (D) {Data};
      \draw (D.east) -- (xor-1.200);
      \draw (fl-1-out) -- ++(1em,0) coordinate (c) -- ++(1em,0);
      \draw (fl-1-out-neg) -- ++(1em,0) -- ++(1em,0);
      \fill (c) circle (1pt);
      \draw (c) |- ($(xor-1.160) + (-1em,1cm)$) |- (xor-1.160);
      \draw (xor-1.east) -- ++(1em,0) |- (fl-1-T);
      \draw (fl-1-clk) -| ++(-1em,-1cm);
   \end{tikzpicture}
\end{center}

\subex{}

Man kann einfach aus dem vorigen D-Flipflop ein RS-Flipflop machen.
\begin{center}
   \begin{tikzpicture}
      % xor gate
      \node[or port,font={=1}] (xor-1) {};

      % fliplop
      \node[flipflop,right=2cm of xor-1] (fl-1) {};
      \node[right,font=\tiny] (fl-1-S) at ($(fl-1.north west) + (0,-10pt)$) {S};
      \node[right,font=\tiny] (fl-1-R) at ($(fl-1.south west) + (0,10pt)$) {R};
      \node[left,font=\tiny] (fl-1-out) at ($(fl-1.north east) + (0,-10pt)$) {Q};
      \node[left,font=\tiny] (fl-1-out-neg) at ($(fl-1.south east) + (0,10pt)$) {$\bar{\text{Q}}$};
      \node[isosceles triangle,shape border rotate=90,anchor=south,draw,inner sep=0,minimum width=4pt]
      (fl-1-clk) at (fl-1.south)  {};

      \node[left=of xor-1.200] (D) {Data};
      \draw (D.east) -- (xor-1.200);
      \draw (fl-1-out) -- ++(1em,0) coordinate (c) -- ++(1em,0);
      \draw (fl-1-out-neg) -- ++(1em,0) -- ++(1em,0);
      \fill (c) circle (1pt);
      \draw (c) |- ($(xor-1.160) + (-1em,1cm)$) |- (xor-1.160);
      \draw (xor-1.east) -- ++(1em,0) coordinate (c) |- (fl-1-S);
      \fill (c) circle (1pt);
      \draw (fl-1-clk) -- ++(0,-1cm);

      % inverter
      \node[inverter,right=of xor-1] (inv-1) {};
      \node[draw,shape=circle,inner sep=1pt,below=-\pgflinewidth of inv-1.south]
      (inv-1-circ) {};
      \draw (c) -- (inv-1);
      \draw (inv-1-circ.south) |- (fl-1-R);
   \end{tikzpicture}
\end{center}





\ex{Analyse eines Registerbausteins}{1 + 4 + 6 + 6 + 8 + 9 }
Im Folgenden sind folgende Symbole gültig:

DATA A = A, DATA B = B, DATA C = C, DATA D = D, ENPENT = E, LOAD = L

\subex{Taktsteuerung}
CLK wird invertiert. Die JK-Flipflops sind normale JK-Flipflops mit Flankensteuerung (siehe Schaltsymbol). Somit negativ einflankengesteuert.

\subex{Einfluss ENT/ENP}
Der Einfluss ist synchron. ENT und ENP sorgen dafür, dass bei der aktiven Zyklusphase die Ergebnisse vom Zeitschritt vorher weiterverarbeitet werden, sofern kein LOAD gesetzt ist.

\bigskip

\textbf{Ansteuergleichungen Allgemein}
\begin{center}
\begin{tabular}{>{$}c<{=$}>{$}l<{$}>{$}l<{$}>{$}l<{$}}
J_A^n & L^n       A^n &+&  \comp L^n              E^n \\
K_A^n & L^n \comp A^n &+& (\comp L^n + \comp A^n) E^n \\
J_B^n & L^n       B^n &+&  \comp L^n              E^n Q_A^{n-1} \comp{Q_D}^{n-1} \\
K_B^n & L^n \comp B^n &+& (\comp L^n + \comp A^n) E^n Q_A^{n-1} \comp{Q_D}^{n-1} \\
J_C^n & L^n       C^n &+&  \comp L^n              E^n Q_A^{n-1} Q_B^{n-1} \\
K_C^n & L^n \comp C^n &+& (\comp L^n + \comp A^n) E^n Q_A^{n-1} Q_B^{n-1} \\
J_D^n & L^n       D^n &+&  \comp L^n              E^n Q_A^{n-1} (Q_B^{n-1} Q_C^{n-1} + Q_D^{n-1})\\
K_D^n & L^n \comp D^n &+& (\comp L^n + \comp A^n) E^n Q_A^{n-1} (Q_B^{n-1} Q_C^{n-1} + Q_D^{n-1})\\
\end{tabular}
\end{center}

\subex{Ansteuergleichungen $\comp {LOAD} = 0$}
\begin{center}
\begin{tabular}{>{$}l<{=$}>{$}l<{$}>{$}l<{$}>{$}l<{$}}
J_A^n & A^n & & \\
K_A^n & \comp A^n & & \\
J_B^n & B^n & & \\
K_B^n & \comp B^n & & \\
J_C^n & C^n & & \\
K_C^n & \comp C^n & & \\
J_D^n & D^n & & \\
K_D^n & \comp D^n & & \\
\end{tabular}
\end{center}

\subex{Ansteuergleichungen $\comp {LOAD} = 1$}
\begin{center}
\begin{tabular}{>{$}l<{=$}>{$}l<{$}>{$}l<{$}>{$}l<{$}}
J_A^n & & & E^n \\
K_A^n & & & E^n \\
J_B^n & & & E^n Q_A^{n-1} \comp {Q_D}^{n-1} \\
K_B^n & & & E^n Q_A^{n-1} \comp {Q_D}^{n-1} \\
J_C^n & & & E^n Q_A^{n-1} Q_B^{n-1} \\
K_C^n & & & E^n Q_A^{n-1} Q_B^{n-1} \\
J_D^n & & & E^n Q_A^{n-1} (Q_B^{n-1} Q_C^{n-1} + Q_D^{n-1})\\
K_D^n & & & E^n Q_A^{n-1} (Q_B^{n-1} Q_C^{n-1} + Q_D^{n-1})\\
\end{tabular}
\end{center}

\subex{Ausgabe Flipflops}
\begin{center}
\begin{tabular}{>{$}l<{$}|c|c|c|c|c|c|c|c|c|c|c|c}
    t & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10& 11\\\hline                                   
J_A^t & u & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
K_A^t & u & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
Q_A^t & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \\\hline                              
J_B^t & u & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 \\
K_B^t & u & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 \\
Q_B^t & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\\hline                                    
J_C^t & u & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
K_C^t & u & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
Q_C^t & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\\hline
J_D^t & u & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 \\
K_D^t & u & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 \\
Q_D^t & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\\hline
\end{tabular}
\end{center}
Wir sehen, dass die Binärzahlen von 0 bis 9 zyklisch ausgegeben werden.

\subex{RCO}
RCO ist der Übertrag wenn auf 10 gewechselt werden würde, bzw. wenn reseted wird.
Das ermöglicht es, dieses Registermodul für eine 1er Stelle des altbekannten BCD-Counters zu nutzen, immer wenn RCO gesetzt wird kann dann die 10er Stelle verändert werden.

\end{document}
