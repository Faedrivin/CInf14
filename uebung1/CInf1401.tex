\documentclass{CInf_practice}

\sheet{1}{Beispiel-CPU H6809}

\begin{document}

\cinftitle

\ex{Arithmetik auf Variablen}{12}

\begin{assemblertable}
%  add & oc & oper & label & op    & oper   & comment
       &    &      &       & .ORG  & \$0500 & Data space                      \\\hline
  0500 &    &      & Z1    & .BYTE & 1      & Variable Z1                     \\\hline
  0501 &    &      & Z2    & .BYTE & 1      & Variable Z2                     \\\hline
  0502 &    &      & ERG   & .BYTE & 1      & Variable ERG                    \\\hline\hline
       &    &      &       & .ORG  & \$0510 & Program space                   \\\hline
  0510 & 4F &      & ADD:  & CLRA  &        & Clear A to perform ADD          \\\hline
  0511 & B6 & 0500 &       & LDA   & Z1     & Load Z1 to A                    \\\hline
  0514 & BB & 0501 &       & ADDA  & Z2     & Add Z2 to A                     \\\hline
  0517 & B7 & 0502 &       & STA   & ERG    & Store A to ERG                  \\\hline
  051A & 7E & 1000 &       & JMP   & \$1000 & Jump out of subroutine          \\\hline
  051D & 4F &      & SUB:  & CLRA  &        & Clear A to perform SUB          \\\hline
  051E & B6 & 0501 &       & LDA   & Z2     & Load Z2 to A                    \\\hline
  0521 & 40 &      &       & NEGA  &        & Two's complement of A           \\\hline
  0522 & BB & 0500 &       & ADDA  & Z1     & Add Z1 to A                     \\\hline
  0525 & B7 & 0502 &       & STA   & ERG    & Store A to ERG                  \\\hline
  0528 & 7E & 1000 &       & JMP   & \$1000 & Jump out of subroutine          \\\hline
  052A & 4F &      & AND:  & CLRA  &        & Clear A to perform AND          \\\hline
  052B & B6 & 0500 &       & LDA   & Z1     & Load Z1 to A                    \\\hline
  052E & B4 & 0501 &       & ANDA  & Z2     & AND Z2 with A                   \\\hline
  0531 & B7 & 0502 &       & STA   & ERG    & Store A to ERG                  \\\hline
  0534 & 7E & 1000 &       & JMP   & \$1000 & Jump out of subroutine          \\\hline
\end{assemblertable}


\ex{For-Schleife}{8+16=24}

\subex{Programmablaufplan}

\newcommand{\la}{\ensuremath{\leftarrow}}
\begin{tikzpicture}[node distance=2cm]
   \node [cloud] (Begin) {Begin};
   \node [block, below=1cm of Begin] (init) {\begin{tabular}{l}LOOP\_SIZE \la 41 \\ LIMIT \la 50 \\
   ZERO \la 0 \\ MINUS\_1 \la FFFF \\ COUNTER \la 1\end{tabular}};
   \node [cloud, below of=init] (Loop) {LOOP};
   \node [block, right=2cm of Loop] (Incr counter) {\begin{tabular}{l}A \la COUNTER \\ A \la A + 1
   \\ COUNTER \la A\end{tabular}};
   \node [decision, above of=Incr counter] (Done?) {A == LOOP\_SIZE?};
   \node [cloud, above of=Done?] (Check Z) {CHK\_Z};
\node [block, above of=Check Z] (Load A X) {\begin{tabular}{l}A \la Z \\ X \la LIMIT \end{tabular}};
   \node [decision,above of=Load A X] (Is A 0?) {A == 0?};
   \node [decision, right=of Check Z] (Is X 0?) {X == 0?};
   \node [cloud, right=of Is A 0?] (Branch2) {BRANCH2};
\node [block, above=1cm of Is X 0?] (Decr) {\begin{tabular}{l} A \la A - 1 \\ X \la X - 1 \end{tabular}};
\node [block, right=of Is X 0?] (Z*=3) {\begin{tabular}{l} A \la Z \\ A \la A + Z \\ A \la A + Z \\ Z \la A \end{tabular}};
   \node [cloud,below=1cm of Is X 0?] (Branch1) {BRANCH1};
\node [block, below=of Branch1] (Z-=50) {\begin{tabular}{l} A \la LIMIT \\ A \la -a \\ A \la A + Z \\ Z \la A \end{tabular}};
   \node [cloud,left=of Load A X] (Exit) {EXIT};

   \path [line] (Begin) -- (init);
   \path [line] (init) -- (Loop);
   \path [line] (Loop) -- (Incr counter);
   \path [line] (Incr counter) -- (Done?);
   \path [line] (Done?) -- (Check Z) node [near start,left] {No};
   \path [line] (Done?) -- (Exit);
   \path [line] (Check Z) -- (Load A X);
   \path [line] (Load A X) -- (Is A 0?);
   \path [line] (Is A 0?) -- (Branch2) node [near start,above] {Yes};
   \path [line] (Is A 0?)  -- (Is X 0?) node [near start,above=5pt] {No};
   \path [line] (Is X 0?)  -- (Branch1) node [near start,left] {Yes};
   \path [line] (Is X 0?)  -- (Decr) node [near start,left] {No};
   \path [line] (Decr.north west)  -| (Is A 0?) {};
   \path [line] (Branch2)  -| (Z*=3) {};
   \path [line] (Z*=3)  -- ++(0,-8cm) -- ($(Loop) + (0,-2cm)$) -- (Loop) {};
   \path [line] (Branch1)  -- (Z-=50) {};
   % \path [line] (Z-=50)  -- (Z-=50) {};
   \node [draw=none] (p) at ($(Loop) + (0,-2cm)$) {};
   \path [line,-] (Z-=50) -- (Z-=50 |- p);

\end{tikzpicture}
% [1] Should we switch LIMIT and ZERO? That way we could load the intermediate value into 
%     the register (line 0824) without having to make assumptions about the low nibble.
%     Like: 0701 ZERO 2 Bytes; 0703 LIMIT 1 Byte; 0824 LDX 0702
%     This would also remove the assumption in 082A.
\begin{assemblertable}
   0000 &    &      &            & .ORG  & \$0700 & Start                        \\\hline
   \vdots & & & & & & \\\hline
   0504 &    &      & Z          & .BYTE & 1 & Variable Z                      \\\hline
   \vdots &  &      &            &       &   &                                 \\\hline
   0700 & ?? &      & LOOP\_SIZE & .BYTE & 1 &                                 \\\hline
   0701 & ?? &      & LIMIT      & .BYTE & 2 & Used in X                       \\\hline
   0703 & ?? &      & ZERO       & .BYTE & 2 & To clear X register             \\\hline
   0705 & ?? &      & MINUS\_1   & .BYTE & 2 & To decrement X                  \\\hline
   0707 & ?? &      & COUNTER    & .BYTE & 1 &                                 \\\hline
   \vdots & & & & & & \\\hline
   0800 & 86 & CE   & INIT:    & LDA  & \#41     & Initialise loop size      \\\hline
   0802 & B7 & 0700 &          & STA  & LOOP\_SIZE &                         \\\hline
   0805 & BE & 0032 &          & LDX  & \#50     & Initialise Z limit        \\\hline
   0807 & BF & 0701 &          & STX  & LIMIT    &                           \\\hline
   080A & 8E & 0000 &          & LDX  & \#0      & Initialise byte for use with X register\\\hline
   080C & BF & 0703 &          & STX  & ZERO     &                           \\\hline
   080F & 8E & FFFF &          & LDX  & \#-1     & Initialise byte for use with X register\\\hline 
   0811 & BF & 0705 &          & STX  & MINUS\_1 &                           \\\hline
   0814 & 86 & 01   &          & LDA  & \#1      & Initialise loop counter   \\\hline
   0816 & B7 & 0707 &          & STA  & COUNTER  &                           \\\hline
   0817 & BE & 0705 &          & LDX  & ZERO     & Zero out X (now redundant)\\\hline
   0818 & B6 & 0707 & LOOP:    & LDA  & COUNTER  & Start loop                \\\hline
   081B & 8B & 01   &          & ADDA & \#1      & Increment counter         \\\hline 
   081D & B7 & 0707 &          & STA  & COUNTER  & Store it                  \\\hline
   0820 & B1 & 0700 &          & CMPA & LOOP\_SIZE & Check if done           \\\hline
   0823 & 27 &      &          & BEQ  & EXIT     & If zero, we're done       \\\hline % misses offset yet
   0825 & B6 & 0504 & CHK\_Z:  & LDA  & Z        & Load Z into A             \\\hline 
   0828 & BE & 0701 &          & LDX  & LIMIT    & Load limit in LIMIT into X.\\\hline 
   082B & 81 & 00   & DECR:    & CMPA & \#0      & Check if Z is zero        \\\hline 
   082D & 27 &      &          & BEQ  & BRANCH2  & If yes, can't be > 50, go to else branch\\\hline % misses offset yet
   082F & 8C & 0703 &          & CMPX & ZERO     & Compare X with 0. \\\hline 
   082C & 27 &      &          & BEQ  & BRANCH1  & If X is 0 instead of Z, then Z is larger.\\\hline % misses offset
   082E & 8B & FF   &          & ADDA & \#-1     & Decrement Z in A          \\\hline
   0830 & 31 & 0705 &          & ADDX & MINUS\_1 & Decrement X by use of MINUS\_1 \\\hline
   0833 & 7E & 0826 &          & JMP  & DECR     & Continue decrement loop   \\\hline
   0836 & B6 & 0702 & BRANCH1: & LDA  & LIMIT+1    & Load 50 into A            \\\hline
   0839 & 40 &      &          & NEGA &          & Make -50                  \\\hline
   083A & BB & 0504 &          & ADDA & Z        & Add -50 to Z              \\\hline
   083D & B7 & 0504 &          & STA  & Z        & Write back into Z         \\\hline
   0840 & 7E & 0818 &          & JMP  & LOOP     & Go to next iteration      \\\hline
   0841 & B6 & 0504 & BRANCH2: & LDA  & Z        & Load Z into A             \\\hline
   0834 & BB & 0504 &          & ADDA & Z        & Add Z to Z               \\\hline
   0837 & BB & 0504 &          & ADDA & Z        & Add Z to Z               \\\hline
   083A & B7 & 0504 &          & STA  & Z        & Write back into Z         \\\hline
   084D & 7E & 0818 &          & JMP  & LOOP     & Go to next iteration      \\\hline
   0850 & 7E & 1000 & EXIT:    & JMP  & \$1000   & Back to OS                \\\hline
\end{assemblertable}


\ex{Taschenrechner}{8+16+8=32}

% \subex{Programmablauf}
%    \newcommand*\circled[1]{\tikz[baseline=(char.base)]{\node[font=\small,minimum
%    size=3ex,left=8pt,below=8pt,shape=circle, draw,inner sep=1pt] (char) {#1};}}


% Das Programm läuft folgendermaßen ab:
% \begin{enumerate}[label=\protect\circled{\arabic*},leftmargin=5em]
%    \item A mit INP initialisieren
%    \item Gültigkeit von INP prüfen
%       \begin{enumerate}
%          \item A += 1
%          \item A \&= 1111 1100. Dies ergibt genau dann nicht 0, wenn eins oder
%             mehr der vorderen 6 Bits und/oder beide der hinteren Bits gesetzt
%             sind. In allen Fällen ist die Eingabe ungültig und es wird ein
%             Fehlerziel angesprungen.
%       \end{enumerate}
%    \item Erneut INP in A laden
%    \item Prüfen, ob INP 00 hinten hat, falls ja, zu Ziel ADD springen
%    \item Erneut INP in A laden
%    \item Prüfen, ob INP 01 hinten hat, falls ja, zu Ziel SUBT springen
%    \item Tritt keiner der Fälle auf, ist die Operation AND
%    \item Für AND Z1 in A laden, mit Z2 verunden, Ergebnis in ERG schreiben
%    \item Für ADD Z1 in A laden, Z2 adieren, Ergebnis in ERG schreiben
%    \item Für SUBT Z2 in A laden, Zweierkomplement auf A anwenden, Z1 addieren,
%       Ergebnis in ERG schreiben
%    \item Beim Fehlerziel 0 in ERG schreiben
%    \item Nach jeder Operation wird die Adresse 1000 angesprungen.
% \end{enumerate}

\begin{assemblertable}
   0000 &    & &     & .ORG  & \$0600 & Start \\\hline
   0500 & ?? & & Z1: & .Byte & 1 & First operand\\\hline
   0501 & ?? & & Z2: & .Byte & 1 & Second operand \\\hline
   0502 & ?? & & ERG: & .Byte & 1 & Result\\\hline
   0503 & ?? & & INP: & .Byte & 1 & Operation\\\hline
   \vdots & & & & & & \\\hline
   0600 & B6 & 0503 & INIT: & LDA & INP & Load operation\\\hline
   0603 & 8B & 01 & & ADDA & \#01 &\\\hline
   0605 & 84 & FC & & ANDA & FC\footnote{\texttt{ = 11111100}}& Check if valid \\\hline
   0607 & 26 & 16\footnote{\texttt{0x061F - 0x0607 - 2}} & SWITCH: & BNE & FAIL & Jump to exit if result nonzero (== false) \\\hline
   0609 & B8 & 0503 & & LDA & INP & Reload operation \\\hline
   060C & 81 & 00 & CHK\_ADD: & CMPA & \#00 & Check if operation is ADD \\\hline
   060E & 27 & F0\footnote{\texttt{0x0700 - 0x060E - 2}} & & BEQ & ADD & Jump to ADD if yes \\\hline
   0610 & 81 & 01 & CHK\_SUBT: & CMPA & \#01 & Check if operation is SUBT \\\hline
   0612 & 27 & FC\footnote{\texttt{0x0700 - 0x0612 - 2}} & & BEQ & SUBT & Jump to SUBT if yes \\\hline
   0614 & B6 & 0500 & AND: & LDA & Z1 & If PC is here, operation is AND \\\hline
   0616 & B4 & 0501 & & ANDA & Z2 & AND with Z2 \\\hline
   0619 & B7 & 0502 & & STA & ERG & write result \\\hline
   061C & 7E & 1000 & EXIT: & JMP & \$1000 & Done \\\hline
   061F & B6 & 0000 & FAIL: & LDA & \#0 & Load register A with 0 \\\hline
   0622 & B7 & 0502 & & STA & ERG & Write result \\\hline
   0625 & 7E & 1000 & & JMP & \$1000 & Done \\\hline

   \vdots & & & & & & \\\hline
   0700 & B6 & 0500 & ADD: & LDA & Z1 & Load first operand \\\hline
   0703 & BB & 0501 & & ADDA & Z1 & Add contents of second operand \\\hline
   0706 & B7 & 0502 & & STA & ERG & Write result \\\hline
   0709 & 7E & 1000 & & JMP & \$1000 & Done \\\hline
   070C & B6 & 0501 & SUBT: & LDA & Z2 & Load second operand \\\hline
   070F & 40 & & & NEGA & & -Z2\ldots \\\hline
   0710 & BB & 0500 & & ADDA & Z1 & \ldots +Z1 \\\hline
   0713 & B7 & 0502 & & STA & ERG & Write result \\\hline
   0716 & 7E & 1000 & & JMP & \$1000 & Done \\\hline
\end{assemblertable}

\ex{Codeumwandlung}{8+16+8=32}

\subex{}


\begin{assemblertable}
%  add & oc & oper & label & op    & oper   & comment
       &    &      &       & .ORG  & \$0500 & data space                      \\\hline
  0504 &    &      & Z     & .BYTE & n      & variable Z                      \\\hline\hline
       &    &      &       & .ORG  & \$8000 & program code                    \\\hline
  8000 & 8E & 0504 & INIT: & LDX   & \#0504 & init register to first char     \\\hline
  8003 & 4F &      &       & CLRA  &        & clear A                         \\\hline
  8004 & A6 &      & LOOP: & LDA   & @X     & load from addr X                \\\hline
  8005 & 43 &      &       & COMA  &        & flip bits, if FF: Z flag 1      \\\hline
  8006 & 27 & 0B   &       & BEQ   & END    & if FF (Z flag): branch to END   \\\hline
  8008 & 43 &      &       & COMA  &        & undo bit flip                   \\\hline
  8009 & 8B & 33   &       & ADDA  & \#33   & adds 00110011(bin) to A         \\\hline
  800B & A7 &      &       & STA   & @X     & store result back               \\\hline
  800C & 30 & 0001 &       & ADDX  & \#0001 & increment X                     \\\hline
  800F & 20 & F5   &       & BRA   & LOOP   & jump -8, i.e. F5                \\\hline
  8011 & 7E & 1000 & END   & JMP   & \$1000 & end program                     \\\hline
\end{assemblertable}

\addex{Multiplikation von Variablen}



\end{document}
