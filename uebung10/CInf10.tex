\documentclass{CInf_practice}

\sheet{10}{Beispiel CPUs HAM und H6809}

\begin{document}
\cinftitle

\ex{Befehlserweiterung der HAM}{5 + 7 + 9 + 5 + 3 + 3}

\subex{\bf SETA}
\lstinputlisting[language=RTeasy,firstline=50,lastline=53]{HAM_extended.rt}
\subex{\bf ADDI}
\lstinputlisting[language=RTeasy,firstline=55,lastline=58]{HAM_extended.rt}
\subex{\bf LOADI}
\lstinputlisting[language=RTeasy,firstline=60,lastline=64]{HAM_extended.rt}
\subex{\bf STOREI}
\lstinputlisting[language=RTeasy,firstline=66,lastline=70]{HAM_extended.rt}

\subex{Testprogramm}

Nach Ausführen des Tests muss an Speicherstelle 9 die Zahl 1 stehen und an 10
nur Einsen. Die Tabelle beinhaltet in der dritten Spalte eine zahl für den
Operanden in den unteren 8 Bit, die dem Opcode folgen (für Ein-Wort-Befehle) und
nach dem Komma den Operanden, der ggf. im zweiten Wort folgt.

\begin{assemblertable}
   0 & 9 & - & & SETA & - & Set accu to all ones \\\hline
   1 & A & -,2 & & ADDI & 2 & Add 2 to accu (will be 1 after) \\\hline
   3 & C & 9,- & & STOREI & 9 & Store accu at address positioned at mem(9)
   (which happens to be 9 again) \\\hline
   4 & B & A,- & & LOADI & 10 & Load value from address stored in mem(10) (which
   is again 10) \\\hline
   5 & 9 & - & & SETA & - & Set accu to all ones \\\hline
   6 & C & A,- & & STOREI & 10 & Store accu at address positioned at mem(10) \\\hline
   \vdots & & & & & & \\\hline
   9 & & & & .DB & 9 & Store value of 9 at position 9\\\hline
   A & & & & .DB & 10 & Store value of 10 at position 10\\\hline
\end{assemblertable}

\subex{Assemblat}

\lstinputlisting{aufg_1_test.mem} % sadly MikTeX can't interpret files without extensions which are not .tex here
                                  % wat ⦾ _ ⦾

\subex{Taktzahl}

Wenn man den FETCH-Zyklus ignoriert, der für alle Befehle gleich lang dauert,
ergeben sich folgende Laufzeiten:
\begin{ctabular}{>{\bf}lr}
   \toprule
   \normalfont{Befehl} & Taktzahl \\\midrule
   SETA & 4 \\
   ADDI & 4 \\
   LOADI & 5 \\
   STOREI & 5
\end{ctabular}

\ex{Collatz-Alg. auf der HAM}{18 + 10 + 4}

\subex{Assemblerprogramm}
\begin{assemblertable}
  00 & 1 & 13 & LOOP:   & LOAD   & VALUE  & load data VALUE     \\\hline
  01 & 4 & 14 &         & AND    & ODDBIT & check if even/odd   \\\hline
  02 & 6 & 0B &         & JUMPZ  & EVEN   & if even: jump       \\\hline
  03 & 1 & 13 & CHECK1: & LOAD   & VALUE  & else: check if 1    \\\hline
  04 & 4 & 15 &         & AND    & INVODD & if 1, then now 0    \\\hline
  05 & 6 & 12 &         & JUMPZ  & END    & if 0, then finish   \\\hline
  06 & 1 & 13 & ODD:    & LOAD   & VALUE  & odd case:           \\\hline
  07 & 3 & 13 &         & ADD    & VALUE  & multiply by 3 with  \\\hline
  08 & 3 & 13 &         & ADD    & VALUE  & \ additions and     \\\hline
  09 & 3 & 14 &         & ADD    & ODDBIT & add 1               \\\hline
  0A & 5 & 0D &         & JUMP   & COUNT  & count the step      \\\hline
  0B & 1 & 13 & EVEN:   & LOAD   & VALUE  &                     \\\hline
  0C & 8 & 00 &         & RSHIFT &        & divide by 2         \\\hline
  0D & 2 & 13 & COUNT:  & STORE  & VALUE  & store the new VALUE \\\hline
  0E & 1 & 16 &         & LOAD   & ERG    & load ERG            \\\hline
  0F & 3 & 14 &         & ADD    & ODDBIT & increment ERG       \\\hline
  10 & 2 & 16 &         & STORE  & ERG    & store ERG           \\\hline
  11 & 5 & 00 &         & JUMP   & LOOP   & repeat from start   \\\hline
  12 & 5 & 12 & END:    & JUMP   & END    & termination loop    \\\hline
  13 & 0 & 0D & VALUE   & .BYTE  &      D & Input Value (13)    \\\hline
  14 & 0 & 01 & ODDBIT  & .BYTE  &      1 & Mask: 000000000001  \\\hline
  15 & F & FE & INVODD  & .BYTE  &    FFE & Mask: 111111111110  \\\hline
  16 & 0 & 00 & ERG     & .BYTE  &      0 & Output Value        \\\hline
\end{assemblertable}

\subex{Handassemblierung}
\lstinputlisting{collatz_ham.mem}

\subex{Speicherbedarf und Laufzeit}
Speicherbedarf: $17\, \left[Speicherstellen\right] \cdot 3\, \left[\frac{Nibbles}{Speicherstelle}\right] \cdot 4\, \left[\frac{Bit}{Nibble}\right] = 204 \left[Bits\right]$.

Laufzeit für $13$: 545 RTeasy Takte bis \texttt{JUMPZ END} ausgeführt ist, danach beliebig viele Takte in \texttt{END: JUMP END}. 

\ex{Collatz-Alg. auf der H6809}{2 + 10 + 8 + 10 + 6}
\subex{Registernutzung}
Durch das X-Register können sehr gut die Adressen von VALUE und ERG bereitgehalten werden, während im Akkumulator wirklich gerechnet wird. Dadurch sparen wir einiges Austauschen im Akkumulator.

\subex{Unterprogramm: Nächste Collatz Zahl}
\begin{assemblertable}
   &    &      &        &      &           & This subroutine changes the\\\hline
   &    &      &        &      &           & current value in the ACC   \\\hline
   &    &      &        &      &           & to it's successor in the   \\\hline
   &    &      &        &      &           & Collatz algorithm.         \\\hline
   &    &      &        &      &           & It is side-effect free.    \\\hline
20 & B7 & 003A & SUBRT: & STA  & TMP       & store input in TMP         \\\hline
23 & 84 &   01 &        & ANDA & 0000 0001 & check odd/even             \\\hline
25 & 27 &   0C &        & BEQ  & EVEN      & if even: branch            \\\hline
27 & B6 & 003A & ODD:   & LDA  & TMP       & reload input               \\\hline
2A & BB & 003A &        & ADDA & TMP       & $A = 2 \cdot TMP$          \\\hline
2D & BB & 003A &        & ADDA & TMP       & $A = 3 \cdot TMP$          \\\hline
30 & 8B &   01 &        & ADDA & 0000 0001 & $A = 3 \cdot TMP + 1$      \\\hline
32 & 39 &      &        & RTS  &           &                            \\\hline
33 & B6 & 003A & EVEN:  & LDA  & TMP       & reload input               \\\hline
36 & 46 &      &        & RORA &           & ``divide by 2''            \\\hline
37 & 84 &   7F &        & ANDA & 0111 1111 & delete first bit           \\\hline
39 & 39 &      &        & RTS  &           &                            \\\hline
3A &    &   00 & TMP    & .BYTE&         0 & TMP, initial 0             \\\hline
\end{assemblertable}
\textbf{Takte:} Odd: 25, Even: 18. 

\begin{itemize}
	\item Gemeinsam: 15 Takte (\texttt{STA, ANDA, BEQ, LDA, RTS}: $4+2+2+4+3=15$)
  \item Odd: +10 Takte (2 $\cdot$ \texttt{ADDA, ADDA}: $2 \cdot 4 + 2 = 10$)
  \item Even: +3 Takte (\texttt{RORA, ANDA}: $1 + 2 = 3$)
\end{itemize}

\subex{Assemblerprogramm}
\begin{assemblertable}
00 & 8E & 001C & INIT:  & LDX  & \#VALUE   & load address of VALUE      \\\hline
03 & A6 &      & LOOP:  & LDA  & @X        & load VALUE                 \\\hline
04 & 8B &   FF &        & ADDA & \$FF      & -1 to check for VALUE=1    \\\hline
06 & 27 &   12 &        & BEQ  & END       & terminate on 1             \\\hline
08 & 8B &   01 &        & ADDA & \$01      & restore VALUE              \\\hline
0A & BD & 0020 &        & JSR  & SUBRT:    & jump to Collatz routine    \\\hline
0D & A7 &      & RETURN:& STA  & @X        & store VALUE                \\\hline
0E & 30 & 0001 &        & ADDX & \$0001    & set X to ERG address       \\\hline
11 & A6 &      &        & LDA  & @X        & load ERG                   \\\hline
12 & 8B &   01 &        & ADDA & \$01      & increment ERG              \\\hline
14 & A7 &      &        & STA  & @X        & store ERG                  \\\hline
15 & 30 & FFFF &        & ADDX & \$FFFF    & restore address of VALUE   \\\hline
18 & 20 &   E9 &        & BRA  & LOOP      & back to LOOP               \\\hline
1A & 20 &   FE & END:   & BRA  & END       & terminate                  \\\hline
1C &    &   0D & VALUE  & .BYTE& D         & VALUE, to test 13          \\\hline
1D &    &   00 & ERG    & .BYTE& 0         & ERG, default 0             \\\hline
\end{assemblertable}
\textbf{Takte (ohne Subroutine):} 
\begin{itemize}
	\item Initialisierung: 3 Takte (\texttt{LDX})
  \item Loop:
  \begin{itemize}
    \item[für 1:] 6 Takte (\texttt{LDA@X, ADDA, BEQ}: $2 + 2 + 2 = 6$)
    \item[sonst:] 25 Takte (\texttt{LDA@X, ADDA, BEQ, ADDA, JSR, STA@X, 
                            ADDX, LDA@X, ADDX, BRA}: 
                            $2 + 2 + 2 + 2 + 5 + 2 + 3 + 2 + 3 + 2 = 25$)
  \end{itemize}
\end{itemize}

\subex{Handassemblierung}
\lstinputlisting{collatz_h6809.mem}

\subex{Speicherbedarf und Laufzeit}
Speicherbedarf: 3 Variablen + 6 Befehle à 1 Byte + 10 Befehle à 2 Byte + 9 Befehle à 3 Byte $\rightarrow$ 53 Byte = 424 Bit.

Laufzeit für $13$: 1210 RTeasy Takte bis \texttt{BRA END} ausgeführt ist, danach beliebig viele Takte in \texttt{END: BRA END}. Auf der realen H6809 wären es 410 Takte:

\begin{ctabular}{rlrr}
Schritt & Programmteil & Collatz-Zahl & Takte \\
0 & Init  &  - &   3 \\
0 & Loop  & 13 &  25 \\
1 & Subrt & 13 &  25 \\
1 & Loop  & 40 &  25 \\
2 & Subrt & 40 &  18 \\
2 & Loop  & 20 &  25 \\
3 & Subrt & 20 &  18 \\
3 & Loop  & 10 &  25 \\
4 & Subrt & 10 &  18 \\
4 & Loop  &  5 &  25 \\
5 & Subrt &  5 &  25 \\
5 & Loop  & 16 &  25 \\
6 & Subrt & 16 &  18 \\
6 & Loop  &  8 &  25 \\
7 & Subrt &  8 &  18 \\
7 & Loop  &  4 &  25 \\
8 & Subrt &  4 &  18 \\
8 & Loop  &  2 &  25 \\
9 & Subrt &  2 &  18 \\
9 & Loop  &  1 &   6 \\\hline\hline
- & Ges.  &  - & 410 \\
\end{ctabular}

Trotz der taktreichen Subroutinen Sprünge ist damit das Programm auf der H6809 schneller (vergleiche: 545 Takte auf der HAM). Das liegt daran, dass durch das Ausnutzen des Adressregisters für die VALUE und ERG Adressen das austauschen der Werte im Akkumulator gespart werden kann.

\end{document}
