\documentclass{CInf_practice}

\sheet{8}{Schaltwerke \& Register-Transfer-Ebene}
\usetikzlibrary{automata,positioning,arrows.meta} 

\begin{document}
\cinftitle

\ex{Füllstandsregelung}{4 + 6 + 12 + 8 = 30}

\subex{Ein- \& Ausgangssignale, Modulbild}
\noindent Eingaben:
\begin{enumerate}[align=left,leftmargin=\marginparwidth]
   \item[$X_t$] Sensor oben (top), 1 = feucht, 0 = trocken
   \item[$X_m$] Sensor mitte (middle), 1 = feucht, 0 = trocken
   \item[$X_b$] Sensor unten (bottom), 1 = feucht, 0 = trocken
\end{enumerate}
Ausgaben:
\begin{enumerate}[align=left,leftmargin=\marginparwidth]
   \item[$Y$] Abflusssteuerung, 1 = öffnen, 0 = schließen
   \item[$E$] Errorsignal, 1 = Error, 0 = kein Error
\end{enumerate}

\begin{center}
  \begin{tikzpicture}
    % module
    \draw (2,3) rectangle node {Sicherheitsfüllstandregler (SFR)} +(6,-2);
    % in
    \draw[<-] (2,2.5) -- node{\tiny /} node[above]{\tiny 1} ++(-1,0) node[left] {$X_t$};
    \draw[<-] (2,2) -- node{\tiny /} node[above]{\tiny 1} ++(-1,0) node[left] {$X_m$};
    \draw[<-] (2,1.5) -- node{\tiny /} node[above]{\tiny 1} ++(-1,0) node[left] {$X_b$};
    % out
    \draw[->] (8,2) -- node{\tiny /} node[above]{\tiny 1} ++(1,0) node[right] {$Y$};
  \end{tikzpicture}
\end{center}


\subex{Zustandsgraph}

\begin{center}
  \begin{tikzpicture}[node distance=4cm]
    \node[state] (A) {A};
    \node[state,right of=A] (B) {B};
    \node[state,below of=B] (C) {C};
    \node[state,left of=C] (D) {D};
    
    \path[->] % inlet
              (A) edge[loop above] node[above] {000/00, 001/00, 011/00} (A) % valid
              (A) edge[loop left]  node[left]  {010/11, 100/11, 101/11, 110/11} (A) % error
              (A) edge             node[above] {111/10} (B) % next
  
              % hold it
              (B) edge[loop above] node[above] {000/00, 001/00, 011/10}(B) % valid
              (B) edge[loop right] node[right] {010/11, 100/11, 101/11, 110/11}(B) % error
              (B) edge             node[right] {111/1}(C) % next
              
              % outlet
              (C) edge[loop below] node[below] {001/10, 011/10, 111/10}(C) % valid
              (C) edge[loop right] node[right] {010/11, 100/11, 101/11, 110/11}(C) % error
              (C) edge             node[below] {000/00}(D) % next
              
              % hold it
              (D) edge[loop below] node[below] {001/00, 011/10, 111/10}(D) % valid
              (D) edge[loop left]  node[left]  {010/11, 100/11, 101/11, 110/11}(D) % error
              (D) edge             node[left]  {000/00}(A) % next
              ;
              
  \end{tikzpicture}
\end{center}
\begin{center}
  \begin{tikzpicture}
    \node[scale=.8,draw,rounded corners=5pt,fill=lightgray!50,text width=4cm] (legend) {
       \makebox[4cm]{Legende}\\
       \hrulefill \\
       %An Zuständen: \makebox[4cm]{$$} \\ 
       An Übergängen: \makebox[4cm]{ $X_tX_mX_b/YE$ }
    };
  \end{tikzpicture}
\end{center}

Der Graph ist konsistent und vollständig.


\subex{Zustandsübergangstabelle \& -codierung}
Vier Zustände erlauben eine Codierung mit $\log_2{4}=2$ Bits. Es scheint sinnvoll, zwischen zwei Zuständen die Hamming distance klein zu halten. Es ist möglich, Codierungen zu finden, bei der für jeden Zustandswechsel nur ein Bit geändert wird. Wir wählen deswegen:

\begin{tabular}{c|m}
Zustand & $Codierung $ = Q_1Q_0 \\\hline
A & 00 \\
B & 10 \\
C & 11 \\
D & 01 \\
\end{tabular}

Für die Realisierung mit JK-Flipflops wird das linke Bit durch das $JK_1$-FF, das recht durch das $JK_0$-FF kodiert. Dabei stehen in der Tabelle $JK_1^{n+1} = Q_1^{n+1}$ bzw. $JK_0^{n+1} = Q_0^{n+1}$ für die jeweiligen Ausgänge, d.h. $1 = Q$ und $0 = \comp Q$.

\begin{tabular}{cc|mmm|mm|c|mmm|mmm}
$Z^n$ & $(Q_1Q_0)^n$ &  X_t & X_m & X_b & Y & E & $(Q_1Q_0)^{n+1}$
      & J_1^n & K_1^n & Q_1^{n+1} & J_0^n & K_0^n & Q_0^{n+1} \\ \hline % do the JK's make sense?
A & 00 & 0 & 0 & 0 & 0 & 0 & 00 & 0 & 1 & 0 & 0 & 1 & 0 \\
A & 00 & 0 & 0 & 1 & 0 & 0 & 00 & 0 & 1 & 0 & 0 & 1 & 0 \\
A & 00 & 0 & 1 & 0 & 1 & 1 & 00 & 0 & 1 & 0 & 0 & 1 & 0 \\
A & 00 & 0 & 1 & 1 & 0 & 0 & 00 & 0 & 1 & 0 & 0 & 1 & 0 \\
A & 00 & 1 & 0 & 0 & 1 & 1 & 00 & 0 & 1 & 0 & 0 & 1 & 0 \\
A & 00 & 1 & 0 & 1 & 1 & 1 & 00 & 0 & 1 & 0 & 0 & 1 & 0 \\
A & 00 & 1 & 1 & 0 & 1 & 1 & 00 & 0 & 1 & 0 & 0 & 1 & 0 \\
A & 00 & 1 & 1 & 1 & 1 & 0 & 01 & 0 & 0 & 0 & 1 & 0 & 1 \\ \hline
B & 01 & 0 & 0 & 0 & 0 & 0 & 01 & 0 & 0 & 0 & 1 & 0 & 1 \\
B & 01 & 0 & 0 & 1 & 0 & 0 & 01 & 0 & 0 & 0 & 1 & 0 & 1 \\
B & 01 & 0 & 1 & 0 & 1 & 1 & 01 & 0 & 0 & 0 & 1 & 0 & 1 \\
B & 01 & 0 & 1 & 1 & 0 & 0 & 01 & 0 & 0 & 0 & 1 & 0 & 1 \\
B & 01 & 1 & 0 & 0 & 1 & 1 & 01 & 0 & 0 & 0 & 1 & 0 & 1 \\
B & 01 & 1 & 0 & 1 & 1 & 1 & 01 & 0 & 0 & 0 & 1 & 0 & 1 \\
B & 01 & 1 & 1 & 0 & 1 & 1 & 01 & 0 & 0 & 0 & 1 & 0 & 1 \\
B & 01 & 1 & 1 & 1 & 1 & 0 & 11 & 1 & 0 & 1 & 1 & 0 & 1 \\ \hline
C & 11 & 0 & 0 & 0 & 0 & 0 & 10 & 1 & 0 & 1 & 0 & 1 & 0 \\
C & 11 & 0 & 0 & 1 & 1 & 0 & 11 & 1 & 0 & 1 & 1 & 0 & 1 \\
C & 11 & 0 & 1 & 0 & 0 & 1 & 11 & 1 & 0 & 1 & 1 & 0 & 1 \\
C & 11 & 0 & 1 & 1 & 1 & 0 & 11 & 1 & 0 & 1 & 1 & 0 & 1 \\
C & 11 & 1 & 0 & 0 & 0 & 1 & 11 & 1 & 0 & 1 & 1 & 0 & 1 \\
C & 11 & 1 & 0 & 1 & 0 & 1 & 11 & 1 & 0 & 1 & 1 & 0 & 1 \\
C & 11 & 1 & 1 & 0 & 0 & 1 & 11 & 1 & 0 & 1 & 1 & 0 & 1 \\
C & 11 & 1 & 1 & 1 & 1 & 0 & 11 & 1 & 0 & 1 & 1 & 0 & 1 \\ \hline
D & 10 & 0 & 0 & 0 & 0 & 0 & 00 & 0 & 1 & 0 & 0 & 1 & 0 \\
D & 10 & 0 & 0 & 1 & 0 & 0 & 10 & 1 & 0 & 1 & 0 & 1 & 0 \\
D & 10 & 0 & 1 & 0 & 1 & 1 & 10 & 1 & 0 & 1 & 0 & 1 & 0 \\
D & 10 & 0 & 1 & 1 & 0 & 0 & 10 & 1 & 0 & 1 & 0 & 1 & 0 \\
D & 10 & 1 & 0 & 0 & 1 & 1 & 10 & 1 & 0 & 1 & 0 & 1 & 0 \\
D & 10 & 1 & 0 & 1 & 1 & 1 & 10 & 1 & 0 & 1 & 0 & 1 & 0 \\
D & 10 & 1 & 1 & 0 & 1 & 1 & 10 & 1 & 0 & 1 & 0 & 1 & 0 \\
D & 10 & 1 & 1 & 1 & 1 & 0 & 10 & 1 & 0 & 1 & 0 & 1 & 0 \\ \hline
\end{tabular}


\subex{Ansteuergleichungen}
Die Wertetabelle wurde zuvor ergänzt. Die Gleichungen können stark vereinfacht werden, da die Zustände nur in wenigen Sonderfällen wechseln. Das Ausnutzen der Hamming distance erlaubt es also im Grunde, die Ansteuergleichungen indirekt durch die vier Zustandswechsel zu definieren.

\begin{align*} % if needed we can simplify this further
Q_0^{n+1} = Q_0^{n} \comp{Q_1^n \comp{X_t} \comp{X_m} \comp{X_b}} + \comp{Q_1^n}\, \comp{Q_1^n} X_t X_m X_b \\
Q_1^{n+1} = Q_1^{n} \comp{Q_0^n \comp{X_t} \comp{X_m} \comp{X_b}} + \comp{Q_1^n}\,       Q_0^n  X_t X_m X_b
\end{align*}



\ex{Konverter}{6 + 12 + 6 + 6 = 30}
\subex{Flowdiagram}
\begin{center}
  \begin{tikzpicture}
    \node[cloud] (Begin) {begin};
    \node[decision, below left=of Begin] (VALID) {VALID=1?};
    \node[block, below=of VALID.south,text width=10em] (store)
          {NUM[0] \la INBUS(0:3)\\NUM[1] \la INBUS(4:7)\\NUM[2] \la INBUS(8:11)};
    \node[block, below=of store,text width=14em] (convout0)
          {READY \la 1\\OUTBUS \la NUM[0] + $0110000_2$};
    \node[block, right=of convout0,text width=14em] (convout1)
          {READY \la 1\\OUTBUS \la NUM[1] + $0110000_2$};
    \node[block, above=of convout1,text width=14em] (convout2)
          {READY \la 1\\OUTBUS \la NUM[2] + $0110000_2$};
    \draw[line] (Begin) -| (VALID);
    \draw[line] (VALID) -- node[left]{yes} (store);
    \draw[line] (store) -- (convout0);
    \draw[line] (convout0) -- (convout1);
    \draw[line] (convout1) -- (convout2);
    \draw[line] (convout2) |- (Begin);
    \draw[line] (VALID) -| node[below, near start] {no} (Begin.south);
  \end{tikzpicture}
\end{center}


\subex{RTeasy Programm}
{
  \lstset{xleftmargin=0pt,xrightmargin=0pt}
  \lstinputlisting{8.2_Konverter.rt}
}


\subex{Zustände, Kontrollsignale und Kriterien}

Die Zustände, Kontrollsignale und Kriterien sind im Code markiert.

\bigskip

\textbf{Zustände:}

\begin{itemize}
	\item \texttt{WAITLOAD}: Wartet auf \texttt{VALID=1} und lädt bei Erfolg.
  \item \texttt{OUTx}: geben jeweils \texttt{NUM[x]} aus.
\end{itemize}

Die Anzahl Zustände kann durch eine Zählvariable auf zwei reduziert werden.

\bigskip

\textbf{Kontrollsignale:}

Die beiden Kontrollsignale sind jeweils \texttt{goto BEGIN}. Wir bezeichnen sie unten mit \emph{back}.

\bigskip

\textbf{Kriterien:}

Das einzige Kriterium ist \texttt{VALID=1}. Wir bezeichnen es im Blockschaltbild mit \emph{load}.


\subex{Blockschaltbild}



\ex{Minimumsuche in RTeasy}{4 + 10 + 11 + 7 + 3 + 5 = 40}
\subex{Blockschaltbild}


\subex{Flowchart}


\subex{RTeasy Programm}


\subex{Kriterien und Signale}

\begin{tabularx}{.8\textwidth}{|L|X|}
\hline
\normalfont{\textbf{Kriterien}} & \textbf{Funktion} \\ \hline
MinbigA   & 1, wenn $Min > A$ \\
AReq31    & 1, wenn $AR=31$ \\ \hline
\hline
\normalfont{\textbf{Kontrollsignale}} & \textbf{Funktion} \\ \hline
& \\
\end{tabularx}


\subex{Taktzahl}


\subex{Technische Realisierung}



\end{document}
