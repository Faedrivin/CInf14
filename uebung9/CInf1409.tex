\documentclass{CInf_practice}

\sheet{9}{RT-Optimierung und Realisierungsprinzipien für Steuerwerke}
\usetikzlibrary{automata,positioning,arrows.meta,fit,shapes.misc}
\lstset{xleftmargin=0pt,xrightmargin=0pt,morekeywords={fi,declare,register,array,bus,memory,goto,then,read}}

\begin{document}
\cinftitle

\ex{Optimierung eines RT-Programms}{10 + 7 + 5 + 8}

\subex{Optimierung ohne Umstrukturierung}
Das Originalprogramm benötigt für 8 Fibonacci-Zahlen 44 Takte, das optimierte
nur 19.
\lstinputlisting{aufg1_a.rt}

\subex{Generelle Optimierung}
Das noch optimiertere Programm benötigt nur mehr 11 Takte für die 8 Zahlen.

\lstinputlisting{aufg1_b.rt}

Wenn man annimmt, dass die 1-Inkremente durch separate Kontrollsignale an die
Register implementiert sind, benötigt man keine zusätzliche Hardware. Würde
jedoch jede Addition von je einer ALU durchgeführt, würde man nun eine mehr
benötigen,
weil in Zeile 12 3 Additionen parallel durchgeführt werden sollen. In dem
Programm aus b) sind es nur maximal 2.

Darüber hinaus ist die Anforderung lediglich, dass Register anfangs 0-initialisiert
sind.

\subex{Modulbild}
\begin{ctabular}{>{\ttfamily}ll}
\textbf{\rmfamily{Kontrollsignal}} & \textbf{Bedeutung} \\
   \hline
   setAR1  & Set AR to 1 \\
   clrA    & Set A to 0 \\
   setB1   & Set B to 1 \\
   clrCNT  & Set CNT to 0 \\
   read    & Read from memory into DR \\
   ldA     & Transfer B to A \\
   ldB     & Transfer A+B to B \\
   incAR   & Increment AR \\
   incCNT  & Increment CNT \\
   ldOUT   & Write CNT to OUTBUS \\
\end{ctabular}
\begin{center}
   \begin{tikzpicture}
      \node[draw,text width=7cm,minimum height=2cm,text centered] (opw) {Operationswerk};

      %% auto-spaced control signals ... hmmmyes.
      \foreach \x[count=\i] in {setAR1,clrA,setB1,clrCNT,read,ldA,ldB,incAR,incCNT,ldOUT}
      {
         \draw[o-] let \p1 = ($(opw.north east) - (opw.north west)$), \n1 =
         {veclen(\x1,\y1)/11} in
         ($(opw.north west) + (\i*\n1,0)$) -- ++(0,{1cm+mod(\i,2)*2em}) coordinate (c);
         \node[above,font=\footnotesize\ttfamily,yshift={mod(\i,2)*1em}] at (c) {\x};
      }
      \draw[-{Latex}] (opw.west) --++ (-1cm,0)
      node[anchor=east,font=\footnotesize\ttfamily] {DRneqA};
   \end{tikzpicture}
\end{center}

\subex{Zustandstabelle}

Jeder Takt im Steuerwerk ist ein Zustand.
Die Ausgabenspalte enthält die Kontrollsignale in der selben Reihenfolge wie die
Tabelle oben:
\begin{center}
   \makebox[.6\linewidth]{\ttfamily setAR1,clrA,setB1,clrCNT,read,ldA,ldB,incAR,incCNT,ldOUT}
\end{center}
\begin{ctabular}{ccccc}
   Kodierung & Zustand & \multicolumn{2}{c}{Folgezustand} & Ausgabe \\
             &         & \texttt{DRneqA} & $\overline{\texttt{DRneqA}}$ & \\\hline
   
   00        & $S_0$   & $S_1$           & $S_1$                        & 0000000000\\
   01        & $S_1$   & $S_3$           & $S_2$                        & 1111100000\\
   11        & $S_2$   & $S_3$           & $S_2$                        & 0000111110\\
   10        & $S_3$   & -               & -                            & 0000000001\\
\end{ctabular}
\ex{One-Hot-Design und Zählersteuerung}{14 + 3 + 14 + 3}
\ex{Mikroprogrammiertes Steuerwerk}{7 + 2 + 4 + 8}
\ex{Mikrobefehlsformate}{5 + 5 + 5}
\end{document}
