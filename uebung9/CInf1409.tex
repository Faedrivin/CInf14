\documentclass{CInf_practice}

\sheet{9}{RT-Optimierung und Realisierungsprinzipien für Steuerwerke}
\usetikzlibrary{automata,positioning,arrows.meta,fit,shapes.misc}
\lstset{xleftmargin=0pt,xrightmargin=0pt,morekeywords={fi,declare,register,array,bus,memory,goto,then,read}}

\begin{document}
\cinftitle

\ex{Optimierung eines RT-Programms}{10 + 7 + 5 + 8}

\subex{Optimierung ohne Umstrukturierung}
Das Originalprogramm benötigt für 8 Fibonacci-Zahlen 44 Takte, das optimierte
nur 19.
\lstinputlisting{aufg1_a.rt}

\subex{Generelle Optimierung}
Das noch optimiertere Programm benötigt nur mehr 11 Takte für die 8 Zahlen.

\lstinputlisting{aufg1_b.rt}

Wenn man annimmt, dass die 1-Inkremente durch separate Kontrollsignale an die
Register implementiert sind, benötigt man keine zusätzliche Hardware. Würde
jedoch jede Addition von je einer ALU durchgeführt, würde man nun eine mehr
benötigen,
weil in Zeile 12 3 Additionen parallel durchgeführt werden sollen. In dem
Programm aus b) sind es nur maximal 2.

Darüber hinaus ist die Anforderung lediglich, dass Register anfangs 0-initialisiert
sind.

\subex{Modulbild}
\begin{ctabular}{>{\ttfamily}ll}
\textbf{\rmfamily{Kontrollsignal}} & \textbf{Bedeutung} \\
   \hline
   setAR1  & Set AR to 1 \\
   clrA    & Set A to 0 \\
   setB1   & Set B to 1 \\
   clrCNT  & Set CNT to 0 \\
   read    & Read from memory into DR \\
   ldA     & Transfer B to A \\
   ldB     & Transfer A+B to B \\
   incAR   & Increment AR \\
   incCNT  & Increment CNT \\
   ldOUT   & Write CNT to OUTBUS \\
\end{ctabular}
\begin{center}
   \begin{tikzpicture}
      \node[draw,text width=7cm,minimum height=2cm,text centered] (opw) {Operationswerk};

      %% auto-spaced control signals ... hmmmyes.
      \foreach \x[count=\i] in {setAR1,clrA,setB1,clrCNT,read,ldA,ldB,incAR,incCNT,ldOUT}
      {
         \draw[o-] let \p1 = ($(opw.north east) - (opw.north west)$), \n1 =
         {veclen(\x1,\y1)/11} in
         ($(opw.north west) + (\i*\n1,0)$) -- ++(0,{1cm+mod(\i,2)*2em}) coordinate (c);
         \node[above,font=\footnotesize\ttfamily,yshift={mod(\i,2)*1em}] at (c) {\x};
      }
      \draw[-{Latex}] (opw.west) --++ (-1cm,0)
      node[anchor=east,font=\footnotesize\ttfamily] {DRneqA};
   \end{tikzpicture}
\end{center}

\subex{Zustandstabelle}

Jeder Takt im Steuerwerk ist ein Zustand.
Die Ausgabenspalte enthält die Kontrollsignale in der selben Reihenfolge wie die
Tabelle oben:
\begin{center}
   \makebox[.6\linewidth]{\ttfamily setAR1,clrA,setB1,clrCNT,read,ldA,ldB,incAR,incCNT,ldOUT}
\end{center}
\begin{ctabular}{ccccc}
   Kodierung & Zustand & \multicolumn{2}{c}{Folgezustand} & Ausgabe \\
             &         & \texttt{DRneqA} & $\overline{\texttt{DRneqA}}$ & \\\hline
   
   00        & $S_0$   & $S_1$           & $S_1$                        & 0000000000\\
   01        & $S_1$   & $S_3$           & $S_2$                        & 1111100000\\
   11        & $S_2$   & $S_3$           & $S_2$                        & 0000111110\\
   10        & $S_3$   & -               & -                            & 0000000001\\
\end{ctabular}
\ex{One-Hot-Design und Zählersteuerung}{14 + 3 + 14 + 3}
Grundlage der folgenden Diagramme ist das vereinfachte Programm aus Aufgabe 1
b), da es am wenigsten Zustände braucht.

\subex{Schaltbild}

Im Prinzip sollten noch ein externes \texttt{BEGIN}-Signal und ein
externes \texttt{END}-Kontrollsignal Teil des Schaltnetzes sein; das Programm
enthält diese jedoch nicht. Der Zustand $S_0$ wird so eher überflüssig, weil er
keine Kontrollsignale generiert.

\tikzset{flipflop/.style={draw,minimum height=2cm,minimum
      width=2cm,text centered,append after command={%
         \pgfextra{ % no idea why this is necessary
            \node[below right=2pt and 1pt of \tikzlastnode.north west] (\tikzlastnode-D) {$D$};
            \node[below left=2pt and 1pt of \tikzlastnode.north east] (\tikzlastnode-Q) {$Q$};
            \node[above left=2pt and 1pt of \tikzlastnode.south east]
            (\tikzlastnode-NOTQ) {$\overline{Q}$};
            \node[above=10pt of \tikzlastnode.south west,inner sep=2pt,isosceles
            triangle,draw,anchor=west] (\tikzlastnode-CLK) {};
            \node[right=-2pt of \tikzlastnode-CLK] {$C\kern-2ptL\kern-2ptK$};
            \node[left=2pt of \tikzlastnode.east] {$\neg$};
         }
      }
   }
}
\begin{center}
   \begin{tikzpicture}[or port/.append style={text width=.7\portsize,minimum height=\portsize}, 
                       and port/.append style={text width=.7\portsize,minimum height=\portsize}
                      ]
      \node[flipflop] (ff-0) {FF0};
      \node[flipflop,below=of ff-0] (ff-1) {FF1};
      \node[flipflop,below=of ff-1] (ff-2) {FF2};
      \node[flipflop,below=of ff-2] (ff-3) {FF3};

      % draw control signal outputs
      \foreach \x[count=\i] in {setAR1,clrA,setB1,clrCNT,read,ldA,ldB,incAR,incCNT,ldOUT}
      {
         \node[or port] (or-\x) at (4cm,{3cm + -1.5*\i cm}) {};
         \draw (or-\x) -- ++(1cm,0) node[anchor=west,font=\ttfamily] {\x};
      }

      \node[and port,left=2cm of ff-2.north west] (and-1) {};
      \node[and port,left=2cm of ff-2.south west] (and-2) {};

      \node[or port,xshift=-2cm] (or-1) at ($(and-1) !0.5! (and-2)$) {};

      \draw (ff-0-D) -- ++(-1cm,0) node[anchor=east] {BEGIN (?)};
      \draw (ff-0-Q) -- ++(1cm,0) |- ($(ff-1-D) + (-1cm,1cm)$) |- (ff-1-D);

      \draw (ff-1-Q) -- ++(1cm,0) |- ($(or-1.150) + (-1cm,1.5cm)$) --
      ($(or-1.150) + (-1cm,0)$) -- (or-1.150);

      \draw[o-] (and-1) -- ++(-2cm,0) node[anchor=east] (notdrneqa) {\texttt{DRneqA}};
      \draw (and-2) -- ++(-2cm,0) node[anchor=east] (drneqa) {\ttfamily{DRneqA}};

      \draw (or-1.east) -- ++(1em,0) coordinate (c);
      \fill (c) circle (2pt);
      \draw (c) |- (and-1.210);
      \draw (c) |- (and-2.150);

      \draw (and-1) -- ++(1cm,0) |- (ff-2-D);
      \draw (and-2) -- ++(1cm,0) |- (ff-3-D);

      \draw (ff-2-Q) -- ++(1cm,0) |- ($(or-1.south west) + (-1cm,-1.2cm)$) --
      ($(or-1.210) + (-1cm,0)$) -- (or-1.210);

      \fill ($(ff-1-Q) + (1cm,0)$) circle (2pt);
      \fill ($(ff-2-Q) + (1cm,0)$) circle (2pt);

      \draw (ff-1-Q) -- ++(2cm,0) coordinate (c);
      \fill (c) circle (2pt);

      % draw paths to outputs for ff1
      \foreach \gate[count=\i] in {setAR1,clrA,setB1,clrCNT,read}{
         \draw let \p1 = (or-\gate.150), \p2 = (c) in (c) -- (\x2,\y1) coordinate
         (c2);
         \ifthenelse{\i=1 \OR \i=5}{}{% prevent circles at actual path corners
            \fill (c2) circle (2pt);
         }
         \draw (c2) -- (or-\gate.150);
      }

      \draw (ff-2-Q) -- ++(1.5cm,0) coordinate (c);
      \fill (c) circle (2pt);

      % draw paths to outputs for ff2
      \foreach \gate[count=\i] in {read,ldA,ldB,incAR,incCNT}{
         \draw let \p1 = (or-\gate.210), \p2 = (c) in (c) -- (\x2,\y1) coordinate
         (c2);
         \ifthenelse{\i=1 \OR \i=5}{}{
            \fill (c2) circle (2pt);
         }
         \draw (c2) -- (or-\gate.210);
      }

      % draw path to outputs for ff3
      \draw (ff-3-Q) -- ++(1cm,0) |- (or-ldOUT);

      % draw clock
      \foreach \ff in {0,...,3}
      {
         \coordinate (c-\ff) at ($(ff-\ff-CLK) + (-1cm,0)$);
         \ifthenelse{\ff=0}{}{\fill (c-\ff) circle (2pt);}
      }
      \node[below=of c-3] (c) {$CLK$};
      \foreach \ff in {0,...,3}{
         \draw (c) |- (ff-\ff-CLK);
      }
   \end{tikzpicture}
\end{center}

\subex{Hardwareaufwand}

Gemäß des obigen Schaltbildes benötigt man für jeden der vier Zustände ein
Flipflop sowie zwei AND-Gatter und zehn OR-Gatter (wenn man \texttt{BEGIN}- und
\texttt{END}-Signale außen vor lässt und den redundanten Zustand $S_0$ behält).
\ex{Mikroprogrammiertes Steuerwerk}{7 + 2 + 4 + 8}
\ex{Mikrobefehlsformate}{5 + 5 + 5}
\end{document}
