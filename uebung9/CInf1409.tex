\documentclass{CInf_practice}

\sheet{9}{RT-Optimierung und Realisierungsprinzipien für Steuerwerke}
\usetikzlibrary{automata,positioning,arrows.meta,fit,shapes.misc}
\lstset{xleftmargin=0pt,xrightmargin=0pt,morekeywords={fi,declare,register,array,bus,memory,goto,then,read}}

\begin{document}
\cinftitle

\ex{Optimierung eines RT-Programms}{10 + 7 + 5 + 8}

\subex{Optimierung ohne Umstrukturierung}
Das Originalprogramm benötigt für 8 Fibonacci-Zahlen 44 Takte, das optimierte
nur 19.
\lstinputlisting{aufg1_a.rt}

\subex{Generelle Optimierung}
Das noch optimiertere Programm benötigt nur mehr 11 Takte für die 8 Zahlen.

\lstinputlisting{aufg1_b.rt}

Wenn man annimmt, dass die 1-Inkremente durch separate Kontrollsignale an die
Register implementiert sind, benötigt man keine zusätzliche Hardware. Würde
jedoch jede Addition von je einer ALU durchgeführt, würde man nun eine mehr
benötigen,
weil in Zeile 12 3 Additionen parallel durchgeführt werden sollen. In dem
Programm aus b) sind es nur maximal 2.

Darüber hinaus ist die Anforderung lediglich, dass Register anfangs 0-initialisiert
sind.

\subex{Modulbild}
\begin{ctabular}{>{\ttfamily}ll}
\textbf{\rmfamily{Kontrollsignal}} & \textbf{Bedeutung} \\
   \hline
   setAR1  & Set AR to 1 \\
   clrA    & Set A to 0 \\
   setB1   & Set B to 1 \\
   clrCNT  & Set CNT to 0 \\
   read    & Read from memory into DR \\
   ldA     & Transfer B to A \\
   ldB     & Transfer A+B to B \\
   incAR   & Increment AR \\
   incCNT  & Increment CNT \\
   ldOUT   & Write CNT to OUTBUS \\
\end{ctabular}
\begin{center}
   \begin{tikzpicture}
      \node[draw,text width=7cm,minimum height=2cm,text centered] (opw) {Operationswerk};

      %% auto-spaced control signals ... hmmmyes.
      \foreach \x[count=\i] in {setAR1,clrA,setB1,clrCNT,read,ldA,ldB,incAR,incCNT,ldOUT}
      {
         \draw[{Latex}-] let \p1 = ($(opw.north east) - (opw.north west)$), \n1 =
         {veclen(\x1,\y1)/11} in
         ($(opw.north west) + (\i*\n1,0)$) -- ++(0,{1cm+mod(\i,2)*2em}) coordinate (c);
         \node[above,font=\footnotesize\ttfamily,yshift={mod(\i,2)*1em}] at (c) {\x};
      }
      \draw[-{Latex}] (opw.west) --++ (-1cm,0)
      node[anchor=east,font=\footnotesize\ttfamily] {DRneqA};
   \end{tikzpicture}
\end{center}

\subex{Zustandstabelle}

Es gibt drei Zustände: Die Initialisierung ($S_0$), die Loop ($S_1$) und den 
Terminalzustand ($S_2$). 
Die Ausgabenspalte enthält die Kontrollsignale in der selben Reihenfolge wie die
Tabelle oben:
\begin{center}
   \makebox[.6\linewidth]{\ttfamily setAR1,clrA,setB1,clrCNT,read,ldA,ldB,incAR,incCNT,ldOUT}
\end{center}
\begin{ctabular}{cccccc}
   Kodierung & Zustand & \multicolumn{2}{c}{Folgezustand} & \multicolumn{2}{c}{Ausgabe} \\
             &         & \texttt{DRneqA} & $\overline{\texttt{DRneqA}}$ & \texttt{DRneqA} & $\overline{\texttt{DRneqA}}$ \\\hline
   00        & $S_0$   & $S_1$           & $S_1$                        & 1111100000 & 1111100000 \\
   01        & $S_1$   & $S_2$           & $S_1$                        & 0000000001 & 0000111110 \\
   10        & $S_2$   & -               & -                            & 0000000000 & 0000000000 \\
\end{ctabular}
\ex{One-Hot-Design und Zählersteuerung}{14 + 3 + 14 + 3}
Grundlage der folgenden Diagramme ist das vereinfachte Programm aus Aufgabe 1
b), da es am wenigsten Zustände braucht.

\subex{Schaltbild}

Im Prinzip sollten noch ein externes \texttt{BEGIN}-Signal und ein
externes \texttt{END}-Kontrollsignal Teil des Schaltnetzes sein; das Programm
enthält diese jedoch nicht. Der Zustand $S_0$ wird so eher überflüssig, weil er
keine Kontrollsignale generiert.

\tikzset{flipflop/.style={draw,minimum height=2cm,minimum
      width=2cm,text centered,append after command={%
         \pgfextra{ % no idea why this is necessary
            \node[below right=2pt and 1pt of \tikzlastnode.north west] (\tikzlastnode-D) {$D$};
            \node[below left=2pt and 1pt of \tikzlastnode.north east] (\tikzlastnode-Q) {$Q$};
            \node[above left=2pt and 1pt of \tikzlastnode.south east]
            (\tikzlastnode-NOTQ) {$\overline{Q}$};
            \node[above=10pt of \tikzlastnode.south west,inner sep=2pt,isosceles
            triangle,draw,anchor=west] (\tikzlastnode-CLK) {};
            \node[right=-2pt of \tikzlastnode-CLK] {$C\kern-2ptL\kern-2ptK$};
            \node[left=2pt of \tikzlastnode.east] {$\neg$};
         }
      }
   }
}
\begin{center}
   \begin{tikzpicture}[or port/.append style={text width=.7\portsize,minimum height=\portsize}, 
                       and port/.append style={text width=.7\portsize,minimum height=\portsize}
                      ]
      %\node[flipflop] (ff-0) {FF0};
      \node[flipflop] (ff-1) {FF0};
      \node[flipflop,below=of ff-1] (ff-2) {FF1};
      \node[flipflop,below=of ff-2] (ff-3) {FF2};

      % draw control signal outputs
      \foreach \x[count=\i] in {setAR1,clrA,setB1,clrCNT,read,ldA,ldB,incAR,incCNT,ldOUT}
      {
         \node[or port] (or-\x) at (4cm,{3cm + -1.5*\i cm}) {};
         \draw (or-\x) -- ++(1cm,0) node[anchor=west,font=\ttfamily] {\x};
      }

      \node[and port,left=2cm of ff-2.north west] (and-1) {};
      \node[and port,left=2cm of ff-2.south west] (and-2) {};

      \node[or port,xshift=-2cm] (or-1) at ($(and-1) !0.5! (and-2)$) {};

      %\draw (ff-0-D) -- ++(-1cm,0) node[anchor=east] {BEGIN (?)};
      %\draw (ff-0-Q) -- ++(1cm,0) |- ($(ff-1-D) + (-1cm,1cm)$) |- (ff-1-D);
      \draw (ff-1-D) -- ++(-1cm,0) node[anchor=east] {BEGIN (?)};

      \draw (ff-1-Q) -- ++(1cm,0) |- ($(or-1.150) + (-1cm,1.5cm)$) --
      ($(or-1.150) + (-1cm,0)$) -- (or-1.150);

      \draw[o-] (and-1) -- ++(-2cm,0) node[anchor=east] (notdrneqa) {\texttt{DRneqA}};
      \draw (and-2) -- ++(-2cm,0) node[anchor=east] (drneqa) {\ttfamily{DRneqA}};

      \draw (or-1.east) -- ++(1em,0) coordinate (c);
      \fill (c) circle (2pt);
      \draw (c) |- (and-1.210);
      \draw (c) |- (and-2.150);

      \draw (and-1) -- ++(1cm,0) |- (ff-2-D);
      \draw (and-2) -- ++(1cm,0) |- (ff-3-D);

      \draw (ff-2-Q) -- ++(1cm,0) |- ($(or-1.south west) + (-1cm,-1.2cm)$) --
      ($(or-1.210) + (-1cm,0)$) -- (or-1.210);

      \fill ($(ff-1-Q) + (1cm,0)$) circle (2pt);
      \fill ($(ff-2-Q) + (1cm,0)$) circle (2pt);

      \draw (ff-1-Q) -- ++(2cm,0) coordinate (c);
      \fill (c) circle (2pt);

      % draw paths to outputs for ff1 (0)
      \foreach \gate[count=\i] in {setAR1,clrA,setB1,clrCNT,read}{
         \draw let \p1 = (or-\gate.150), \p2 = (c) in (c) -- (\x2,\y1) coordinate
         (c2);
         \ifthenelse{\i=1 \OR \i=5}{}{% prevent circles at actual path corners
            \fill (c2) circle (2pt);
         }
         \draw (c2) -- (or-\gate.150);
      }

      \draw (ff-2-Q) -- ++(1.5cm,0) coordinate (c);
      %\fill (c) circle (2pt);

      % draw paths to outputs for ff2 (1)
      \foreach \gate[count=\i] in {read,ldA,ldB,incAR,incCNT}{
         \draw let \p1 = (or-\gate.210), \p2 = (c) in (c) -- (\x2,\y1) coordinate
         (c2);
         \ifthenelse{\i=5}{}{
            \fill (c2) circle (2pt);
         }
         \draw (c2) -- (or-\gate.210);
      }

      % draw path to outputs for ff3 (2)
      \draw (ff-3-Q) -- ++(1cm,0) |- (or-ldOUT);

      % draw clock
      \foreach \ff in {1,...,3}
      {
         \coordinate (c-\ff) at ($(ff-\ff-CLK) + (-1cm,0)$);
         \ifthenelse{\ff=1}{}{\fill (c-\ff) circle (2pt);}
      }
      \node[below=of c-3] (c) {$CLK$};
      \foreach \ff in {1,...,3}{
         \draw (c) |- (ff-\ff-CLK);
      }
   \end{tikzpicture}
\end{center}

\subex{Hardwareaufwand}

Gemäß des obigen Schaltbildes benötigt man für jeden der drei Zustände ein
Flipflop sowie insgesamt zwei AND-Gatter und elf OR-Gatter (wenn man \texttt{BEGIN}- und
\texttt{END}-Signale außen vor lässt).
Man kann die Kontrollsignalausgabe reduzieren, da die meisten Signale nur von
genau einem Zustand generiert werden. Neun der Gatter sind im Prinzip
überflüssig, sodass man auch  mit insgesamt zwei OR-Gattern auskommt.

\subex{Zählersteuerung}
%Wir benötigen ein weiteres Kontrollsignal (\texttt{InitScs}), um den Counter nach der Initialisierung zu erhöhen.

\begin{center} 
  \begin{tikzpicture}[or port/.append style={text width=.7\portsize,minimum height=\portsize}, 
                      and port/.append style={text width=.7\portsize,minimum height=\portsize}]
      
      %\node[flipflop] (ff-0) {FF0};
      \node[flipflop] (ff-1) {FF0};
      \node[flipflop,below=of ff-1] (ff-2) {FF1};
      \node[flipflop,below=of ff-2] (ff-3) {FF2};

      % barbarian additions: and gates and counter
      \draw ($(ff-1)+(.75,3)$) rectangle node[align=center] (counter) {Modulo-1\\sequence\\counter} ++(3,2);
      \node[and port, right=2cm of ff-1.north east] (and-z1) {};
      \node[and port, right=2cm of ff-2.north east] (and-z2) {};
      \node[and port, right=2cm of ff-3.north east] (and-z3) {};
      \draw[-,name path=phi1] ($(ff-1)+(2.25,3)$) -- ++(0,-10cm) node[below] {$\Phi_1$};
      \draw[opacity=0,name path=and-z1-line] (and-z1.150) -- ++(-5cm,0);
      \draw[-*,name intersections={of=and-z1-line and phi1}] (and-z1.150) --($(intersection-1)+(-0.08,0)$);
      \draw[opacity=0,name path=and-z2-line] (and-z2.150) -- ++(-5cm,0);
      \draw[-*,name intersections={of=and-z2-line and phi1}] (and-z2.150) --($(intersection-1)+(-0.08,0)$);
      \draw[opacity=0,name path=and-z3-line] (and-z3.150) -- ++(-5cm,0);
      \draw[-*,name intersections={of=and-z3-line and phi1}] (and-z3.150) --($(intersection-1)+(-0.08,0)$);
      % BEGIN to counter
      \draw[-*] ($(ff-1)+(.75,4)$) -| ($(ff-1-D)+(-0.75,-0.08)$);

      % draw control signal outputs
      \foreach \x[count=\i] in {setAR1,clrA,setB1,clrCNT,read,ldA,ldB,incAR,incCNT,ldOUT}
      {
         \node[or port] (or-\x) at (6.5cm,{3cm + -1.5*\i cm}) {};
         \draw (or-\x) -- ++(1cm,0) node[anchor=west,font=\ttfamily] {\x};
      }

      \node[and port,left=2cm of ff-2.north west] (and-1) {};
      \node[and port,left=2cm of ff-2.south west] (and-2) {};

      \node[or port,xshift=-2cm] (or-1) at ($(and-1) !0.5! (and-2)$) {};

      %\draw (ff-0-D) -- ++(-1cm,0) node[anchor=east] {BEGIN (?)};
      %\draw (ff-0-Q) -- ++(1cm,0) |- ($(ff-1-D) + (-1cm,1cm)$) |- (ff-1-D);
      \draw (ff-1-D) -- ++(-1cm,0) node[anchor=east] {BEGIN (?)};

      \draw (ff-1-Q) -- ++(1cm,0) |- ($(or-1.150) + (-1cm,1.5cm)$) --
      ($(or-1.150) + (-1cm,0)$) -- (or-1.150);

      \draw[o-] (and-1) -- ++(-2cm,0) node[anchor=east] (notdrneqa) {\texttt{DRneqA}};
      \draw (and-2) -- ++(-2cm,0) node[anchor=east] (drneqa) {\ttfamily{DRneqA}};

      \draw (or-1.east) -- ++(1em,0) coordinate (c);
      \fill (c) circle (2pt);
      \draw (c) |- (and-1.210);
      \draw (c) |- (and-2.150);

      \draw (and-1) -- ++(1cm,0) |- (ff-2-D);
      \draw (and-2) -- ++(1cm,0) |- (ff-3-D);

      \draw (ff-2-Q) -- ++(1cm,0) |- ($(or-1.south west) + (-1cm,-1.2cm)$) --
      ($(or-1.210) + (-1cm,0)$) -- (or-1.210);

      \fill ($(ff-1-Q) + (1cm,0)$) circle (2pt);
      \fill ($(ff-2-Q) + (1cm,0)$) circle (2pt);
      
      % flip flop Qs to and-gates
      \draw ($(ff-1-Q) + (1cm,0)$) -| (and-z1.south west);
      \draw ($(ff-2-Q) + (1cm,0)$) -| (and-z2.south west);
      \draw (ff-3-Q) -| (and-z3.south west);

      %\draw (ff-1-Q) -- ++(2cm,0) coordinate (c);
      \draw (and-z1) -- ++(2cm,0) coordinate (c);
      \fill (c) circle (2pt);

      % draw paths to outputs for ff1 (0)
      \foreach \gate[count=\i] in {setAR1,clrA,setB1,clrCNT,read}{
         \draw let \p1 = (or-\gate.150), \p2 = (c) in (c) -- (\x2,\y1) coordinate
         (c2);
         \ifthenelse{\i=1 \OR \i=5}{}{% prevent circles at actual path corners
            \fill (c2) circle (2pt);
         }
         \draw (c2) -- (or-\gate.150);
      }

      %\draw (ff-2-Q) -- ++(1.5cm,0) coordinate (c);
      \draw (and-z2) -- ++(1.5cm,0) coordinate (c);
      %\fill (c) circle (2pt);

      % draw paths to outputs for ff2 (1)
      \foreach \gate[count=\i] in {read,ldA,ldB,incAR,incCNT}{
         \draw let \p1 = (or-\gate.210), \p2 = (c) in (c) -- (\x2,\y1) coordinate
         (c2);
         \ifthenelse{\i=5}{}{
            \fill (c2) circle (2pt);
         }
         \draw (c2) -- (or-\gate.210);
      }

      % draw path to outputs for ff3 (2)
      %\draw (ff-3-Q) -- ++(1cm,0) |- (or-ldOUT);
      \draw (and-z3) -- ++(1cm,0) |- (or-ldOUT);

      % draw clock
      \foreach \ff in {1,...,3}
      {
         \coordinate (c-\ff) at ($(ff-\ff-CLK) + (-1cm,0)$);
         \ifthenelse{\ff=1}{}{\fill (c-\ff) circle (2pt);}
      }
      \node[below=of c-3] (c) {$CLK$};
      \foreach \ff in {1,...,3}{
         \draw (c) |- (ff-\ff-CLK);
      }
  \end{tikzpicture}
\end{center}

\subex{Hardwareaufwand}
Es werden für jeden Zustand ein zusätzliches AND-Gatter sowie der Zähler mehr benötigt (sowie ein paar Drähte und Lötzinn).

\ex{Mikroprogrammiertes Steuerwerk}{7 + 2 + 4 + 8}

\subex{Mikroprogramm}
% this makes no sense at all to me, but maybe it's right...
Es gibt keine komplexen if/else Konstrukte und deshalb muss die Verzweigung umgebaut werden. Nur ein simples goto ist möglich für das Branching.
\lstinputlisting{aufg3_a.rt}

\subex{Programmflusskontrolle durch MUX}
Ein MUXer könnte z.B. ein 2 Bit-Condition-Select haben. 

\begin{center}
\begin{tabular}{|rl|}
Cond. Select & Operation \\\hline
00 & k. Verzw. \\
01 & Verzw. wenn \texttt{DRneqA} = 1 \\
10 & unbed. Verzw. \\
11 & k. Verzw. \\
\end{tabular}
\end{center}

\subex{Horizontales Befehlsformat}
So hätten wir eine 2 Bit Condition, eine 5 Bit Adresse und noch 10 Bit für die 10 Signale (\texttt{setAR1, clrA, setB1, clrCNT, read, ldA, ldB, incAR, incCNT, ldOUT}), d.h. unsere Befehle sind insgesamt 17 Bit breit.

\subex{Horizontales Mikroprogramm}

\def\ctrl#1{\rotatebox{90}{\texttt{#1}}}
\begin{center}
\begin{tabular}{|c|c|c|cccccccccc|c|}
  \hline
  \bf Addr. & \bf Cond. & \bf Branch & \multicolumn{10}{|c|}{\bf Control fields} & \\
\bf in CM & \bf select & \bf addr. & \ctrl{setAR1} & \ctrl{clrA} & \ctrl{setB1} & \ctrl{clrCNT} & \ctrl{read} & \ctrl{ldA} & \ctrl{ldB} & \ctrl{incAR} & \ctrl{incCNT} & \ctrl{ldOUT} & Comments \\ \hline
0000 & 00 & 0000 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & \parbox{4cm}{\small AR \la 1, B \la 1, read MEM;} \\ \hline
0001 & 01 & 0011 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \parbox{4cm}{\small if DR <> A then goto 3 fi;} \\ \hline
0010 & 10 & 0001 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & \parbox{4cm}{\small A \la B, B \la A + B, AR \la AR + 1, CNT \la CNT + 1, read Mem | goto 1;}\\ \hline
0011 & 00 & 0000 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & \parbox{4cm}{\small OUTBUS \la CNT;} \\ \hline
\end{tabular}
\end{center}


\ex{Mikrobefehlsformate}{5 + 5 + 5}
\subex{Minimiertes Horizontales Mikroprogramm}
Die Signale \texttt{setAR1, setB1} und \texttt{read} werden im Signal \texttt{init} zusammengefasst, die Signale \texttt{read, ldA, ldB, incAR, incCNT} im Signal \texttt{cnt}. Übrig bleibt noch das Signal \texttt{ldOUT}, was nicht weiter zusammengefasst wird. Die Signale \texttt{clrA} und \texttt{clrCNT} können ignoriert werden.

Da wir nur vier Zeilen Code haben, können wir für die Sprungadresse 3 bit nutzen. Springen wir sogar nur relativ brauchen wir maximal Sprünge der Größe 3 und können den Multiplexer wie folgt kodieren:

\textbf{Relative Verzweigung}

\begin{center}
\begin{tabular}{|rl|}
Condition Select & Operation \\\hline
00 & keine Verzweigung \\
01 & bedingte Verzweigung relativ vor wenn \texttt{DRneqA} = 1 \\
10 & unbedingte Verzweigung relativ zurück \\
11 & keine Verzweigung \\
\end{tabular}
\end{center}
Das erlaubt es uns, die Addressbreite auf 2 Bit zu reduzieren.

Insgesamt ist die Breite eines Codewortes nun 2 Bit Condition select + 2 Bit Adressoffset + 3 Bit Signale = 7 Bit.

\def\ctrl#1{\rotatebox{90}{\texttt{#1}}}
\begin{center}
\begin{tabular}{|c|c|c|ccc|c|}
  \hline
  \bf Addr. & \bf Cond. & \bf Branch & \multicolumn{3}{|c|}{\bf Control fields} & \\
\bf in CM & \bf select & \bf addr. & \ctrl{init} & \ctrl{cnt} & \ctrl{ldOUT} & Comments \\ \hline
0000 & 00 & 00 & 1 & 0 & 0 & \parbox{4cm}{\small AR \la 1, B \la 1, read MEM;} \\ \hline
0001 & 01 & 10 & 0 & 0 & 0 & \parbox{4cm}{\small if DR <> A then go 2 fi;} \\ \hline
0010 & 10 & 01 & 0 & 1 & 0 & \parbox{4cm}{\small A \la B, B \la A + B, AR \la AR + 1, CNT \la CNT + 1, read Mem | go back 1;}\\ \hline
0011 & 00 & 00 & 0 & 0 & 1 & \parbox{4cm}{\small OUTBUS \la CNT;} \\ \hline
\end{tabular}
\end{center}

Das gesamte Programm ist also 28 Bit groß.

Sollte keine relative Verzweigung möglich, so ist die Breite eines Codewortes mindestens 8 Bit, die Gesamtlänge ändert sich entsprechend um 4 Bit auf 32 Bit.

\textbf{Absolute Verzweigung}

\begin{center}
\begin{tabular}{|rl|}
Condition Select & Operation \\\hline
00 & keine Verzweigung \\
01 & bedingte Verzweigung wenn \texttt{DRneqA} = 1 \\
10 & unbedingte Verzweigung \\
11 & keine Verzweigung \\
\end{tabular}
\end{center}
\def\ctrl#1{\rotatebox{90}{\texttt{#1}}}
\begin{center}
\begin{tabular}{|c|c|c|ccc|c|}
  \hline
  \bf Addr. & \bf Cond. & \bf Branch & \multicolumn{3}{|c|}{\bf Control fields} & \\
\bf in CM & \bf select & \bf addr. & \ctrl{init} & \ctrl{cnt} & \ctrl{ldOUT} & Comments \\ \hline
0000 & 00 & 000 & 1 & 0 & 0 & \parbox{4cm}{\small AR \la 1, B \la 1, read MEM;} \\ \hline
0001 & 01 & 011 & 0 & 0 & 0 & \parbox{4cm}{\small if DR <> A then goto 3 fi;} \\ \hline
0010 & 10 & 001 & 0 & 1 & 0 & \parbox{4cm}{\small A \la B, B \la A + B, AR \la AR + 1, CNT \la CNT + 1, read Mem | goto 1;}\\ \hline
0011 & 00 & 000 & 0 & 0 & 1 & \parbox{4cm}{\small OUTBUS \la CNT;} \\ \hline
\end{tabular}
\end{center}


\subex{Vertikales Mikroprogramm}
Für das vertikale Mikroprogramm können wir die Befehle kodieren. Da wir im Grunde genommen nur 4 Befehle haben, können wir diese bereits mit 2 Bit kodieren:

\begin{center}
\begin{tabular}{|rl|}
Kodierung & Signal \\ \hline
00 & \texttt{init} \\
01 & \sl bedingtes Branchen \\
10 & \texttt{cnt} \\
11 & \texttt{ldOUT} \\
\end{tabular}
\end{center}
Der Decoder braucht so zwei Eingänge und drei Ausgänge (zehn Ausgänge, wenn die kompletten Codewörter ohne Zusammenfassung dekodiert werden sollen).
Das Programm wird aber nur um 4 Bit kleiner (1 Bit pro Wort).

\subex{Variables Befehlsformat für Mikroprogamme}

\textbf{Relative Verzweigung}

\def\ctrl#1{\rotatebox{90}{\texttt{#1}}}
\begin{center}
\begin{tabular}{|c|c|c|ccc|c|}
  \hline
  \bf Addr. & \bf Cond. & \bf Branch & \multicolumn{3}{|c|}{\bf Control fields} & \\
\bf in CM & \bf select & \bf addr. & \ctrl{init} & \ctrl{cnt} & \ctrl{ldOUT} & Comments \\ \hline
0000 & 00 & 00 & 1 & 0 & 0 & \parbox{4cm}{\small AR \la 1, B \la 1, read MEM;} \\ \hline
0001 & 01 & 11 & 0 & 0 & 0 & \parbox{4cm}{\small if DR <> A then go 3 fi;} \\ \hline
0010 & 00 & 00 & 0 & 1 & 0 & \parbox{4cm}{\small A \la B, B \la A + B, AR \la AR + 1, CNT \la CNT + 1, read Mem;}\\ \hline
0011 & 10 & 10 & 0 & 0 & 0 & \parbox{4cm}{\small go back 2;} \\ \hline
0100 & 00 & 00 & 0 & 0 & 1 & \parbox{4cm}{\small OUTBUS \la CNT;} \\ \hline
\end{tabular}
\end{center}
Das Programm braucht einen Befehl mehr und wird somit um dessen Breite länger. Damit ergeben sich 35 Bit (relatives Branching) bzw. 40 Bit (absolutes Branching mit 3-Bit-Adressen).

\textbf{Absolute Verzweigung}

\def\ctrl#1{\rotatebox{90}{\texttt{#1}}}
\begin{center}
\begin{tabular}{|c|c|c|ccc|c|}
  \hline
  \bf Addr. & \bf Cond. & \bf Branch & \multicolumn{3}{|c|}{\bf Control fields} & \\
\bf in CM & \bf select & \bf addr. & \ctrl{init} & \ctrl{cnt} & \ctrl{ldOUT} & Comments \\ \hline
0000 & 00 & 000 & 1 & 0 & 0 & \parbox{4cm}{\small AR \la 1, B \la 1, read MEM;} \\ \hline
0001 & 01 & 100 & 0 & 0 & 0 & \parbox{4cm}{\small if DR <> A then goto 4 fi;} \\ \hline
0010 & 00 & 000 & 0 & 1 & 0 & \parbox{4cm}{\small A \la B, B \la A + B, AR \la AR + 1, CNT \la CNT + 1, read Mem;}\\ \hline
0011 & 10 & 001 & 0 & 0 & 0 & \parbox{4cm}{\small goto 1;} \\ \hline
0100 & 00 & 000 & 0 & 0 & 1 & \parbox{4cm}{\small OUTBUS \la CNT;} \\ \hline
\end{tabular}
\end{center}

\end{document}
